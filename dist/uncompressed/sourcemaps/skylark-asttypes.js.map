{"version":3,"sources":["skylark-asttypes.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-asttypes.js","sourcesContent":["define('skylark-asttypes/types',[],function () {\n    'use strict';\n    const Op = Object.prototype;\n    const objToStr = Op.toString;\n    const hasOwn = Op.hasOwnProperty;\n    class BaseType {\n        assert(value, deep) {\n            if (!this.check(value, deep)) {\n                var str = shallowStringify(value);\n                throw new Error(str + ' does not match type ' + this);\n            }\n            return true;\n        }\n        arrayOf() {\n            const elemType = this;\n            return new ArrayType(elemType);\n        }\n    }\n    class ArrayType extends BaseType {\n        constructor(elemType) {\n            super();\n            this.elemType = elemType;\n            this.kind = 'ArrayType';\n        }\n        toString() {\n            return '[' + this.elemType + ']';\n        }\n        check(value, deep) {\n            return Array.isArray(value) && value.every(elem => this.elemType.check(elem, deep));\n        }\n    }\n    class IdentityType extends BaseType {\n        constructor(value) {\n            super();\n            this.value = value;\n            this.kind = 'IdentityType';\n        }\n        toString() {\n            return String(this.value);\n        }\n        check(value, deep) {\n            const result = value === this.value;\n            if (!result && typeof deep === 'function') {\n                deep(this, value);\n            }\n            return result;\n        }\n    }\n    class ObjectType extends BaseType {\n        constructor(fields) {\n            super();\n            this.fields = fields;\n            this.kind = 'ObjectType';\n        }\n        toString() {\n            return '{ ' + this.fields.join(', ') + ' }';\n        }\n        check(value, deep) {\n            return objToStr.call(value) === objToStr.call({}) && this.fields.every(field => {\n                return field.type.check(value[field.name], deep);\n            });\n        }\n    }\n    class OrType extends BaseType {\n        constructor(types) {\n            super();\n            this.types = types;\n            this.kind = 'OrType';\n        }\n        toString() {\n            return this.types.join(' | ');\n        }\n        check(value, deep) {\n            if (this.types.some(type => type.check(value, !!deep))) {\n                return true;\n            }\n            if (typeof deep === 'function') {\n                deep(this, value);\n            }\n            return false;\n        }\n    }\n    class PredicateType extends BaseType {\n        constructor(name, predicate) {\n            super();\n            this.name = name;\n            this.predicate = predicate;\n            this.kind = 'PredicateType';\n        }\n        toString() {\n            return this.name;\n        }\n        check(value, deep) {\n            const result = this.predicate(value, deep);\n            if (!result && typeof deep === 'function') {\n                deep(this, value);\n            }\n            return result;\n        }\n    }\n    class Def {\n        constructor(type, typeName) {\n            this.type = type;\n            this.typeName = typeName;\n            this.baseNames = [];\n            this.ownFields = Object.create(null);\n            this.allSupertypes = Object.create(null);\n            this.supertypeList = [];\n            this.allFields = Object.create(null);\n            this.fieldNames = [];\n            this.finalized = false;\n            this.buildable = false;\n            this.buildParams = [];\n        }\n        isSupertypeOf(that) {\n            if (that instanceof Def) {\n                if (this.finalized !== true || that.finalized !== true) {\n                    throw new Error('');\n                }\n                return hasOwn.call(that.allSupertypes, this.typeName);\n            } else {\n                throw new Error(that + ' is not a Def');\n            }\n        }\n        checkAllFields(value, deep) {\n            var allFields = this.allFields;\n            if (this.finalized !== true) {\n                throw new Error('' + this.typeName);\n            }\n            function checkFieldByName(name) {\n                var field = allFields[name];\n                var type = field.type;\n                var child = field.getValue(value);\n                return type.check(child, deep);\n            }\n            return value !== null && typeof value === 'object' && Object.keys(allFields).every(checkFieldByName);\n        }\n        bases(...supertypeNames) {\n            var bases = this.baseNames;\n            if (this.finalized) {\n                if (supertypeNames.length !== bases.length) {\n                    throw new Error('');\n                }\n                for (var i = 0; i < supertypeNames.length; i++) {\n                    if (supertypeNames[i] !== bases[i]) {\n                        throw new Error('');\n                    }\n                }\n                return this;\n            }\n            supertypeNames.forEach(baseName => {\n                if (bases.indexOf(baseName) < 0) {\n                    bases.push(baseName);\n                }\n            });\n            return this;\n        }\n    }\n    class Field {\n        constructor(name, type, defaultFn, hidden) {\n            this.name = name;\n            this.type = type;\n            this.defaultFn = defaultFn;\n            this.hidden = !!hidden;\n        }\n        toString() {\n            return JSON.stringify(this.name) + ': ' + this.type;\n        }\n        getValue(obj) {\n            var value = obj[this.name];\n            if (typeof value !== 'undefined') {\n                return value;\n            }\n            if (typeof this.defaultFn === 'function') {\n                value = this.defaultFn.call(obj);\n            }\n            return value;\n        }\n    }\n    function shallowStringify(value) {\n        if (Array.isArray(value)) {\n            return '[' + value.map(shallowStringify).join(', ') + ']';\n        }\n        if (value && typeof value === 'object') {\n            return '{ ' + Object.keys(value).map(function (key) {\n                return key + ': ' + value[key];\n            }).join(', ') + ' }';\n        }\n        return JSON.stringify(value);\n    }\n    \n    function typesPlugin(_fork) {\n        const Type = {\n            or(...types) {\n                return new OrType(types.map(type => Type.from(type)));\n            },\n            from(value, name) {\n                if (value instanceof ArrayType || value instanceof IdentityType || value instanceof ObjectType || value instanceof OrType || value instanceof PredicateType) {\n                    return value;\n                }\n                if (value instanceof Def) {\n                    return value.type;\n                }\n                if (isArray.check(value)) {\n                    if (value.length !== 1) {\n                        throw new Error('only one element type is permitted for typed arrays');\n                    }\n                    return new ArrayType(Type.from(value[0]));\n                }\n                if (isObject.check(value)) {\n                    return new ObjectType(Object.keys(value).map(name => {\n                        return new Field(name, Type.from(value[name], name));\n                    }));\n                }\n                if (typeof value === 'function') {\n                    var bicfIndex = builtInCtorFns.indexOf(value);\n                    if (bicfIndex >= 0) {\n                        return builtInCtorTypes[bicfIndex];\n                    }\n                    if (typeof name !== 'string') {\n                        throw new Error('missing name');\n                    }\n                    return new PredicateType(name, value);\n                }\n                return new IdentityType(value);\n            },\n            def(typeName) {\n                return hasOwn.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);\n            },\n            hasDef(typeName) {\n                return hasOwn.call(defCache, typeName);\n            }\n        };\n        var builtInCtorFns = [];\n        var builtInCtorTypes = [];\n        function defBuiltInType(name, example) {\n            const objStr = objToStr.call(example);\n            const type = new PredicateType(name, value => objToStr.call(value) === objStr);\n            if (example && typeof example.constructor === 'function') {\n                builtInCtorFns.push(example.constructor);\n                builtInCtorTypes.push(type);\n            }\n            return type;\n        }\n        const isString = defBuiltInType('string', 'truthy');\n        const isFunction = defBuiltInType('function', function () {\n        });\n        const isArray = defBuiltInType('array', []);\n        const isObject = defBuiltInType('object', {});\n        const isRegExp = defBuiltInType('RegExp', /./);\n        const isDate = defBuiltInType('Date', new Date());\n        const isNumber = defBuiltInType('number', 3);\n        const isBoolean = defBuiltInType('boolean', true);\n        const isNull = defBuiltInType('null', null);\n        const isUndefined = defBuiltInType('undefined', undefined);\n        const isBigInt = typeof BigInt === 'function' ? defBuiltInType('BigInt', BigInt(1234)) : new PredicateType('BigInt', () => false);\n        const builtInTypes = {\n            string: isString,\n            function: isFunction,\n            array: isArray,\n            object: isObject,\n            RegExp: isRegExp,\n            Date: isDate,\n            number: isNumber,\n            boolean: isBoolean,\n            null: isNull,\n            undefined: isUndefined,\n            BigInt: isBigInt\n        };\n        var defCache = Object.create(null);\n        function defFromValue(value) {\n            if (value && typeof value === 'object') {\n                var type = value.type;\n                if (typeof type === 'string' && hasOwn.call(defCache, type)) {\n                    var d = defCache[type];\n                    if (d.finalized) {\n                        return d;\n                    }\n                }\n            }\n            return null;\n        }\n        class DefImpl extends Def {\n            constructor(typeName) {\n                super(new PredicateType(typeName, (value, deep) => this.check(value, deep)), typeName);\n            }\n            check(value, deep) {\n                if (this.finalized !== true) {\n                    throw new Error('prematurely checking unfinalized type ' + this.typeName);\n                }\n                if (value === null || typeof value !== 'object') {\n                    return false;\n                }\n                var vDef = defFromValue(value);\n                if (!vDef) {\n                    if (this.typeName === 'SourceLocation' || this.typeName === 'Position') {\n                        return this.checkAllFields(value, deep);\n                    }\n                    return false;\n                }\n                if (deep && vDef === this) {\n                    return this.checkAllFields(value, deep);\n                }\n                if (!this.isSupertypeOf(vDef)) {\n                    return false;\n                }\n                if (!deep) {\n                    return true;\n                }\n                return vDef.checkAllFields(value, deep) && this.checkAllFields(value, false);\n            }\n            build(...buildParams) {\n                this.buildParams = buildParams;\n                if (this.buildable) {\n                    return this;\n                }\n                this.field('type', String, () => this.typeName);\n                this.buildable = true;\n                const addParam = (built, param, arg, isArgAvailable) => {\n                    if (hasOwn.call(built, param))\n                        return;\n                    var all = this.allFields;\n                    if (!hasOwn.call(all, param)) {\n                        throw new Error('' + param);\n                    }\n                    var field = all[param];\n                    var type = field.type;\n                    var value;\n                    if (isArgAvailable) {\n                        value = arg;\n                    } else if (field.defaultFn) {\n                        value = field.defaultFn.call(built);\n                    } else {\n                        var message = 'no value or default function given for field ' + JSON.stringify(param) + ' of ' + this.typeName + '(' + this.buildParams.map(function (name) {\n                            return all[name];\n                        }).join(', ') + ')';\n                        throw new Error(message);\n                    }\n                    if (!type.check(value)) {\n                        throw new Error(shallowStringify(value) + ' does not match field ' + field + ' of type ' + this.typeName);\n                    }\n                    built[param] = value;\n                };\n                const builder = (...args) => {\n                    var argc = args.length;\n                    if (!this.finalized) {\n                        throw new Error('attempting to instantiate unfinalized type ' + this.typeName);\n                    }\n                    var built = Object.create(nodePrototype);\n                    this.buildParams.forEach(function (param, i) {\n                        if (i < argc) {\n                            addParam(built, param, args[i], true);\n                        } else {\n                            addParam(built, param, null, false);\n                        }\n                    });\n                    Object.keys(this.allFields).forEach(function (param) {\n                        addParam(built, param, null, false);\n                    });\n                    if (built.type !== this.typeName) {\n                        throw new Error('');\n                    }\n                    return built;\n                };\n                builder.from = obj => {\n                    if (!this.finalized) {\n                        throw new Error('attempting to instantiate unfinalized type ' + this.typeName);\n                    }\n                    var built = Object.create(nodePrototype);\n                    Object.keys(this.allFields).forEach(function (param) {\n                        if (hasOwn.call(obj, param)) {\n                            addParam(built, param, obj[param], true);\n                        } else {\n                            addParam(built, param, null, false);\n                        }\n                    });\n                    if (built.type !== this.typeName) {\n                        throw new Error('');\n                    }\n                    return built;\n                };\n                Object.defineProperty(builders, getBuilderName(this.typeName), {\n                    enumerable: true,\n                    value: builder\n                });\n                return this;\n            }\n            field(name, type, defaultFn, hidden) {\n                if (this.finalized) {\n                    console.error('Ignoring attempt to redefine field ' + JSON.stringify(name) + ' of finalized type ' + JSON.stringify(this.typeName));\n                    return this;\n                }\n                this.ownFields[name] = new Field(name, Type.from(type), defaultFn, hidden);\n                return this;\n            }\n            finalize() {\n                if (!this.finalized) {\n                    var allFields = this.allFields;\n                    var allSupertypes = this.allSupertypes;\n                    this.baseNames.forEach(name => {\n                        var def = defCache[name];\n                        if (def instanceof Def) {\n                            def.finalize();\n                            extend(allFields, def.allFields);\n                            extend(allSupertypes, def.allSupertypes);\n                        } else {\n                            var message = 'unknown supertype name ' + JSON.stringify(name) + ' for subtype ' + JSON.stringify(this.typeName);\n                            throw new Error(message);\n                        }\n                    });\n                    extend(allFields, this.ownFields);\n                    allSupertypes[this.typeName] = this;\n                    this.fieldNames.length = 0;\n                    for (var fieldName in allFields) {\n                        if (hasOwn.call(allFields, fieldName) && !allFields[fieldName].hidden) {\n                            this.fieldNames.push(fieldName);\n                        }\n                    }\n                    Object.defineProperty(namedTypes, this.typeName, {\n                        enumerable: true,\n                        value: this.type\n                    });\n                    this.finalized = true;\n                    populateSupertypeList(this.typeName, this.supertypeList);\n                    if (this.buildable && this.supertypeList.lastIndexOf('Expression') >= 0) {\n                        wrapExpressionBuilderWithStatement(this.typeName);\n                    }\n                }\n            }\n        }\n        function getSupertypeNames(typeName) {\n            if (!hasOwn.call(defCache, typeName)) {\n                throw new Error('');\n            }\n            var d = defCache[typeName];\n            if (d.finalized !== true) {\n                throw new Error('');\n            }\n            return d.supertypeList.slice(1);\n        }\n        function computeSupertypeLookupTable(candidates) {\n            var table = {};\n            var typeNames = Object.keys(defCache);\n            var typeNameCount = typeNames.length;\n            for (var i = 0; i < typeNameCount; ++i) {\n                var typeName = typeNames[i];\n                var d = defCache[typeName];\n                if (d.finalized !== true) {\n                    throw new Error('' + typeName);\n                }\n                for (var j = 0; j < d.supertypeList.length; ++j) {\n                    var superTypeName = d.supertypeList[j];\n                    if (hasOwn.call(candidates, superTypeName)) {\n                        table[typeName] = superTypeName;\n                        break;\n                    }\n                }\n            }\n            return table;\n        }\n        var builders = Object.create(null);\n        var nodePrototype = {};\n        function defineMethod(name, func) {\n            var old = nodePrototype[name];\n            if (isUndefined.check(func)) {\n                delete nodePrototype[name];\n            } else {\n                isFunction.assert(func);\n                Object.defineProperty(nodePrototype, name, {\n                    enumerable: true,\n                    configurable: true,\n                    value: func\n                });\n            }\n            return old;\n        }\n        function getBuilderName(typeName) {\n            return typeName.replace(/^[A-Z]+/, function (upperCasePrefix) {\n                var len = upperCasePrefix.length;\n                switch (len) {\n                case 0:\n                    return '';\n                case 1:\n                    return upperCasePrefix.toLowerCase();\n                default:\n                    return upperCasePrefix.slice(0, len - 1).toLowerCase() + upperCasePrefix.charAt(len - 1);\n                }\n            });\n        }\n        function getStatementBuilderName(typeName) {\n            typeName = getBuilderName(typeName);\n            return typeName.replace(/(Expression)?$/, 'Statement');\n        }\n        var namedTypes = {};\n        function getFieldNames(object) {\n            var d = defFromValue(object);\n            if (d) {\n                return d.fieldNames.slice(0);\n            }\n            if ('type' in object) {\n                throw new Error('did not recognize object of type ' + JSON.stringify(object.type));\n            }\n            return Object.keys(object);\n        }\n        function getFieldValue(object, fieldName) {\n            var d = defFromValue(object);\n            if (d) {\n                var field = d.allFields[fieldName];\n                if (field) {\n                    return field.getValue(object);\n                }\n            }\n            return object && object[fieldName];\n        }\n        function eachField(object, callback, context) {\n            getFieldNames(object).forEach(function (name) {\n                callback.call(this, name, getFieldValue(object, name));\n            }, context);\n        }\n        function someField(object, callback, context) {\n            return getFieldNames(object).some(function (name) {\n                return callback.call(this, name, getFieldValue(object, name));\n            }, context);\n        }\n        function wrapExpressionBuilderWithStatement(typeName) {\n            var wrapperName = getStatementBuilderName(typeName);\n            if (builders[wrapperName])\n                return;\n            var wrapped = builders[getBuilderName(typeName)];\n            if (!wrapped)\n                return;\n            const builder = function (...args) {\n                return builders.expressionStatement(wrapped.apply(builders, args));\n            };\n            builder.from = function (...args) {\n                return builders.expressionStatement(wrapped.from.apply(builders, args));\n            };\n            builders[wrapperName] = builder;\n        }\n        function populateSupertypeList(typeName, list) {\n            list.length = 0;\n            list.push(typeName);\n            var lastSeen = Object.create(null);\n            for (var pos = 0; pos < list.length; ++pos) {\n                typeName = list[pos];\n                var d = defCache[typeName];\n                if (d.finalized !== true) {\n                    throw new Error('');\n                }\n                if (hasOwn.call(lastSeen, typeName)) {\n                    delete list[lastSeen[typeName]];\n                }\n                lastSeen[typeName] = pos;\n                list.push.apply(list, d.baseNames);\n            }\n            for (var to = 0, from = to, len = list.length; from < len; ++from) {\n                if (hasOwn.call(list, from)) {\n                    list[to++] = list[from];\n                }\n            }\n            list.length = to;\n        }\n        function extend(into, from) {\n            Object.keys(from).forEach(function (name) {\n                into[name] = from[name];\n            });\n            return into;\n        }\n        function finalize() {\n            Object.keys(defCache).forEach(function (name) {\n                defCache[name].finalize();\n            });\n        }\n        return {\n            Type,\n            builtInTypes,\n            getSupertypeNames,\n            computeSupertypeLookupTable,\n            builders,\n            defineMethod,\n            getBuilderName,\n            getStatementBuilderName,\n            namedTypes,\n            getFieldNames,\n            getFieldValue,\n            eachField,\n            someField,\n            finalize,\n        };\n    };\n    \n    return typesPlugin;\n});\ndefine('skylark-asttypes/path',['./types'], function (typesPlugin) {\n    'use strict';\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    return function pathPlugin(fork) {\n        var types = fork.use(typesPlugin);\n        var isArray = types.builtInTypes.array;\n        var isNumber = types.builtInTypes.number;\n        const Path = function Path(value, parentPath, name) {\n            if (!(this instanceof Path)) {\n                throw new Error(\"Path constructor cannot be invoked without 'new'\");\n            }\n            if (parentPath) {\n                if (!(parentPath instanceof Path)) {\n                    throw new Error('');\n                }\n            } else {\n                parentPath = null;\n                name = null;\n            }\n            this.value = value;\n            this.parentPath = parentPath;\n            this.name = name;\n            this.__childCache = null;\n        };\n        var Pp = Path.prototype;\n        function getChildCache(path) {\n            return path.__childCache || (path.__childCache = Object.create(null));\n        }\n        function getChildPath(path, name) {\n            var cache = getChildCache(path);\n            var actualChildValue = path.getValueProperty(name);\n            var childPath = cache[name];\n            if (!hasOwn.call(cache, name) || childPath.value !== actualChildValue) {\n                childPath = cache[name] = new path.constructor(actualChildValue, path, name);\n            }\n            return childPath;\n        }\n        Pp.getValueProperty = function getValueProperty(name) {\n            return this.value[name];\n        };\n        Pp.get = function get(...names) {\n            var path = this;\n            var count = names.length;\n            for (var i = 0; i < count; ++i) {\n                path = getChildPath(path, names[i]);\n            }\n            return path;\n        };\n        Pp.each = function each(callback, context) {\n            var childPaths = [];\n            var len = this.value.length;\n            var i = 0;\n            for (var i = 0; i < len; ++i) {\n                if (hasOwn.call(this.value, i)) {\n                    childPaths[i] = this.get(i);\n                }\n            }\n            context = context || this;\n            for (i = 0; i < len; ++i) {\n                if (hasOwn.call(childPaths, i)) {\n                    callback.call(context, childPaths[i]);\n                }\n            }\n        };\n        Pp.map = function map(callback, context) {\n            var result = [];\n            this.each(function (childPath) {\n                result.push(callback.call(this, childPath));\n            }, context);\n            return result;\n        };\n        Pp.filter = function filter(callback, context) {\n            var result = [];\n            this.each(function (childPath) {\n                if (callback.call(this, childPath)) {\n                    result.push(childPath);\n                }\n            }, context);\n            return result;\n        };\n        function emptyMoves() {\n        }\n        function getMoves(path, offset, start, end) {\n            isArray.assert(path.value);\n            if (offset === 0) {\n                return emptyMoves;\n            }\n            var length = path.value.length;\n            if (length < 1) {\n                return emptyMoves;\n            }\n            var argc = arguments.length;\n            if (argc === 2) {\n                start = 0;\n                end = length;\n            } else if (argc === 3) {\n                start = Math.max(start, 0);\n                end = length;\n            } else {\n                start = Math.max(start, 0);\n                end = Math.min(end, length);\n            }\n            isNumber.assert(start);\n            isNumber.assert(end);\n            var moves = Object.create(null);\n            var cache = getChildCache(path);\n            for (var i = start; i < end; ++i) {\n                if (hasOwn.call(path.value, i)) {\n                    var childPath = path.get(i);\n                    if (childPath.name !== i) {\n                        throw new Error('');\n                    }\n                    var newIndex = i + offset;\n                    childPath.name = newIndex;\n                    moves[newIndex] = childPath;\n                    delete cache[i];\n                }\n            }\n            delete cache.length;\n            return function () {\n                for (var newIndex in moves) {\n                    var childPath = moves[newIndex];\n                    if (childPath.name !== +newIndex) {\n                        throw new Error('');\n                    }\n                    cache[newIndex] = childPath;\n                    path.value[newIndex] = childPath.value;\n                }\n            };\n        }\n        Pp.shift = function shift() {\n            var move = getMoves(this, -1);\n            var result = this.value.shift();\n            move();\n            return result;\n        };\n        Pp.unshift = function unshift(...args) {\n            var move = getMoves(this, args.length);\n            var result = this.value.unshift.apply(this.value, args);\n            move();\n            return result;\n        };\n        Pp.push = function push(...args) {\n            isArray.assert(this.value);\n            delete getChildCache(this).length;\n            return this.value.push.apply(this.value, args);\n        };\n        Pp.pop = function pop() {\n            isArray.assert(this.value);\n            var cache = getChildCache(this);\n            delete cache[this.value.length - 1];\n            delete cache.length;\n            return this.value.pop();\n        };\n        Pp.insertAt = function insertAt(index) {\n            var argc = arguments.length;\n            var move = getMoves(this, argc - 1, index);\n            if (move === emptyMoves && argc <= 1) {\n                return this;\n            }\n            index = Math.max(index, 0);\n            for (var i = 1; i < argc; ++i) {\n                this.value[index + i - 1] = arguments[i];\n            }\n            move();\n            return this;\n        };\n        Pp.insertBefore = function insertBefore(...args) {\n            var pp = this.parentPath;\n            var argc = args.length;\n            var insertAtArgs = [this.name];\n            for (var i = 0; i < argc; ++i) {\n                insertAtArgs.push(args[i]);\n            }\n            return pp.insertAt.apply(pp, insertAtArgs);\n        };\n        Pp.insertAfter = function insertAfter(...args) {\n            var pp = this.parentPath;\n            var argc = args.length;\n            var insertAtArgs = [this.name + 1];\n            for (var i = 0; i < argc; ++i) {\n                insertAtArgs.push(args[i]);\n            }\n            return pp.insertAt.apply(pp, insertAtArgs);\n        };\n        function repairRelationshipWithParent(path) {\n            if (!(path instanceof Path)) {\n                throw new Error('');\n            }\n            var pp = path.parentPath;\n            if (!pp) {\n                return path;\n            }\n            var parentValue = pp.value;\n            var parentCache = getChildCache(pp);\n            if (parentValue[path.name] === path.value) {\n                parentCache[path.name] = path;\n            } else if (isArray.check(parentValue)) {\n                var i = parentValue.indexOf(path.value);\n                if (i >= 0) {\n                    parentCache[path.name = i] = path;\n                }\n            } else {\n                parentValue[path.name] = path.value;\n                parentCache[path.name] = path;\n            }\n            if (parentValue[path.name] !== path.value) {\n                throw new Error('');\n            }\n            if (path.parentPath.get(path.name) !== path) {\n                throw new Error('');\n            }\n            return path;\n        }\n        Pp.replace = function replace(replacement) {\n            var results = [];\n            var parentValue = this.parentPath.value;\n            var parentCache = getChildCache(this.parentPath);\n            var count = arguments.length;\n            repairRelationshipWithParent(this);\n            if (isArray.check(parentValue)) {\n                var originalLength = parentValue.length;\n                var move = getMoves(this.parentPath, count - 1, this.name + 1);\n                var spliceArgs = [\n                    this.name,\n                    1\n                ];\n                for (var i = 0; i < count; ++i) {\n                    spliceArgs.push(arguments[i]);\n                }\n                var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);\n                if (splicedOut[0] !== this.value) {\n                    throw new Error('');\n                }\n                if (parentValue.length !== originalLength - 1 + count) {\n                    throw new Error('');\n                }\n                move();\n                if (count === 0) {\n                    delete this.value;\n                    delete parentCache[this.name];\n                    this.__childCache = null;\n                } else {\n                    if (parentValue[this.name] !== replacement) {\n                        throw new Error('');\n                    }\n                    if (this.value !== replacement) {\n                        this.value = replacement;\n                        this.__childCache = null;\n                    }\n                    for (i = 0; i < count; ++i) {\n                        results.push(this.parentPath.get(this.name + i));\n                    }\n                    if (results[0] !== this) {\n                        throw new Error('');\n                    }\n                }\n            } else if (count === 1) {\n                if (this.value !== replacement) {\n                    this.__childCache = null;\n                }\n                this.value = parentValue[this.name] = replacement;\n                results.push(this);\n            } else if (count === 0) {\n                delete parentValue[this.name];\n                delete this.value;\n                this.__childCache = null;\n            } else {\n                throw new Error('Could not replace path');\n            }\n            return results;\n        };\n        return Path;\n    };\n});\ndefine('skylark-asttypes/scope',['./types'], function (typesPlugin) {\n    'use strict';\n    var hasOwn = Object.prototype.hasOwnProperty;\n    return function scopePlugin(fork) {\n        var types = fork.use(typesPlugin);\n        var Type = types.Type;\n        var namedTypes = types.namedTypes;\n        var Node = namedTypes.Node;\n        var Expression = namedTypes.Expression;\n        var isArray = types.builtInTypes.array;\n        var b = types.builders;\n        const Scope = function Scope(path, parentScope) {\n            if (!(this instanceof Scope)) {\n                throw new Error(\"Scope constructor cannot be invoked without 'new'\");\n            }\n            if (!TypeParameterScopeType.check(path.value)) {\n                ScopeType.assert(path.value);\n            }\n            var depth;\n            if (parentScope) {\n                if (!(parentScope instanceof Scope)) {\n                    throw new Error('');\n                }\n                depth = parentScope.depth + 1;\n            } else {\n                parentScope = null;\n                depth = 0;\n            }\n            Object.defineProperties(this, {\n                path: { value: path },\n                node: { value: path.value },\n                isGlobal: {\n                    value: !parentScope,\n                    enumerable: true\n                },\n                depth: { value: depth },\n                parent: { value: parentScope },\n                bindings: { value: {} },\n                types: { value: {} }\n            });\n        };\n        var ScopeType = Type.or(namedTypes.Program, namedTypes.Function, namedTypes.CatchClause);\n        var TypeParameterScopeType = Type.or(namedTypes.Function, namedTypes.ClassDeclaration, namedTypes.ClassExpression, namedTypes.InterfaceDeclaration, namedTypes.TSInterfaceDeclaration, namedTypes.TypeAlias, namedTypes.TSTypeAliasDeclaration);\n        var FlowOrTSTypeParameterType = Type.or(namedTypes.TypeParameter, namedTypes.TSTypeParameter);\n        Scope.isEstablishedBy = function (node) {\n            return ScopeType.check(node) || TypeParameterScopeType.check(node);\n        };\n        var Sp = Scope.prototype;\n        Sp.didScan = false;\n        Sp.declares = function (name) {\n            this.scan();\n            return hasOwn.call(this.bindings, name);\n        };\n        Sp.declaresType = function (name) {\n            this.scan();\n            return hasOwn.call(this.types, name);\n        };\n        Sp.declareTemporary = function (prefix) {\n            if (prefix) {\n                if (!/^[a-z$_]/i.test(prefix)) {\n                    throw new Error('');\n                }\n            } else {\n                prefix = 't$';\n            }\n            prefix += this.depth.toString(36) + '$';\n            this.scan();\n            var index = 0;\n            while (this.declares(prefix + index)) {\n                ++index;\n            }\n            var name = prefix + index;\n            return this.bindings[name] = types.builders.identifier(name);\n        };\n        Sp.injectTemporary = function (identifier, init) {\n            identifier || (identifier = this.declareTemporary());\n            var bodyPath = this.path.get('body');\n            if (namedTypes.BlockStatement.check(bodyPath.value)) {\n                bodyPath = bodyPath.get('body');\n            }\n            bodyPath.unshift(b.variableDeclaration('var', [b.variableDeclarator(identifier, init || null)]));\n            return identifier;\n        };\n        Sp.scan = function (force) {\n            if (force || !this.didScan) {\n                for (var name in this.bindings) {\n                    delete this.bindings[name];\n                }\n                for (var name in this.types) {\n                    delete this.types[name];\n                }\n                scanScope(this.path, this.bindings, this.types);\n                this.didScan = true;\n            }\n        };\n        Sp.getBindings = function () {\n            this.scan();\n            return this.bindings;\n        };\n        Sp.getTypes = function () {\n            this.scan();\n            return this.types;\n        };\n        function scanScope(path, bindings, scopeTypes) {\n            var node = path.value;\n            if (TypeParameterScopeType.check(node)) {\n                const params = path.get('typeParameters', 'params');\n                if (isArray.check(params.value)) {\n                    params.each(childPath => {\n                        addTypeParameter(childPath, scopeTypes);\n                    });\n                }\n            }\n            if (ScopeType.check(node)) {\n                if (namedTypes.CatchClause.check(node)) {\n                    addPattern(path.get('param'), bindings);\n                } else {\n                    recursiveScanScope(path, bindings, scopeTypes);\n                }\n            }\n        }\n        function recursiveScanScope(path, bindings, scopeTypes) {\n            var node = path.value;\n            if (path.parent && namedTypes.FunctionExpression.check(path.parent.node) && path.parent.node.id) {\n                addPattern(path.parent.get('id'), bindings);\n            }\n            if (!node) {\n            } else if (isArray.check(node)) {\n                path.each(childPath => {\n                    recursiveScanChild(childPath, bindings, scopeTypes);\n                });\n            } else if (namedTypes.Function.check(node)) {\n                path.get('params').each(paramPath => {\n                    addPattern(paramPath, bindings);\n                });\n                recursiveScanChild(path.get('body'), bindings, scopeTypes);\n                recursiveScanScope(path.get('typeParameters'), bindings, scopeTypes);\n            } else if (namedTypes.TypeAlias && namedTypes.TypeAlias.check(node) || namedTypes.InterfaceDeclaration && namedTypes.InterfaceDeclaration.check(node) || namedTypes.TSTypeAliasDeclaration && namedTypes.TSTypeAliasDeclaration.check(node) || namedTypes.TSInterfaceDeclaration && namedTypes.TSInterfaceDeclaration.check(node)) {\n                addTypePattern(path.get('id'), scopeTypes);\n            } else if (namedTypes.VariableDeclarator.check(node)) {\n                addPattern(path.get('id'), bindings);\n                recursiveScanChild(path.get('init'), bindings, scopeTypes);\n            } else if (node.type === 'ImportSpecifier' || node.type === 'ImportNamespaceSpecifier' || node.type === 'ImportDefaultSpecifier') {\n                addPattern(path.get(node.local ? 'local' : node.name ? 'name' : 'id'), bindings);\n            } else if (Node.check(node) && !Expression.check(node)) {\n                types.eachField(node, function (name, child) {\n                    var childPath = path.get(name);\n                    if (!pathHasValue(childPath, child)) {\n                        throw new Error('');\n                    }\n                    recursiveScanChild(childPath, bindings, scopeTypes);\n                });\n            }\n        }\n        function pathHasValue(path, value) {\n            if (path.value === value) {\n                return true;\n            }\n            if (Array.isArray(path.value) && path.value.length === 0 && Array.isArray(value) && value.length === 0) {\n                return true;\n            }\n            return false;\n        }\n        function recursiveScanChild(path, bindings, scopeTypes) {\n            var node = path.value;\n            if (!node || Expression.check(node)) {\n            } else if (namedTypes.FunctionDeclaration.check(node) && node.id !== null) {\n                addPattern(path.get('id'), bindings);\n            } else if (namedTypes.ClassDeclaration && namedTypes.ClassDeclaration.check(node) && node.id !== null) {\n                addPattern(path.get('id'), bindings);\n                recursiveScanScope(path.get('typeParameters'), bindings, scopeTypes);\n            } else if (namedTypes.InterfaceDeclaration && namedTypes.InterfaceDeclaration.check(node) || namedTypes.TSInterfaceDeclaration && namedTypes.TSInterfaceDeclaration.check(node)) {\n                addTypePattern(path.get('id'), scopeTypes);\n            } else if (ScopeType.check(node)) {\n                if (namedTypes.CatchClause.check(node) && namedTypes.Identifier.check(node.param)) {\n                    var catchParamName = node.param.name;\n                    var hadBinding = hasOwn.call(bindings, catchParamName);\n                    recursiveScanScope(path.get('body'), bindings, scopeTypes);\n                    if (!hadBinding) {\n                        delete bindings[catchParamName];\n                    }\n                }\n            } else {\n                recursiveScanScope(path, bindings, scopeTypes);\n            }\n        }\n        function addPattern(patternPath, bindings) {\n            var pattern = patternPath.value;\n            namedTypes.Pattern.assert(pattern);\n            if (namedTypes.Identifier.check(pattern)) {\n                if (hasOwn.call(bindings, pattern.name)) {\n                    bindings[pattern.name].push(patternPath);\n                } else {\n                    bindings[pattern.name] = [patternPath];\n                }\n            } else if (namedTypes.AssignmentPattern && namedTypes.AssignmentPattern.check(pattern)) {\n                addPattern(patternPath.get('left'), bindings);\n            } else if (namedTypes.ObjectPattern && namedTypes.ObjectPattern.check(pattern)) {\n                patternPath.get('properties').each(function (propertyPath) {\n                    var property = propertyPath.value;\n                    if (namedTypes.Pattern.check(property)) {\n                        addPattern(propertyPath, bindings);\n                    } else if (namedTypes.Property.check(property) || namedTypes.ObjectProperty && namedTypes.ObjectProperty.check(property)) {\n                        addPattern(propertyPath.get('value'), bindings);\n                    } else if (namedTypes.SpreadProperty && namedTypes.SpreadProperty.check(property)) {\n                        addPattern(propertyPath.get('argument'), bindings);\n                    }\n                });\n            } else if (namedTypes.ArrayPattern && namedTypes.ArrayPattern.check(pattern)) {\n                patternPath.get('elements').each(function (elementPath) {\n                    var element = elementPath.value;\n                    if (namedTypes.Pattern.check(element)) {\n                        addPattern(elementPath, bindings);\n                    } else if (namedTypes.SpreadElement && namedTypes.SpreadElement.check(element)) {\n                        addPattern(elementPath.get('argument'), bindings);\n                    }\n                });\n            } else if (namedTypes.PropertyPattern && namedTypes.PropertyPattern.check(pattern)) {\n                addPattern(patternPath.get('pattern'), bindings);\n            } else if (namedTypes.SpreadElementPattern && namedTypes.SpreadElementPattern.check(pattern) || namedTypes.RestElement && namedTypes.RestElement.check(pattern) || namedTypes.SpreadPropertyPattern && namedTypes.SpreadPropertyPattern.check(pattern)) {\n                addPattern(patternPath.get('argument'), bindings);\n            }\n        }\n        function addTypePattern(patternPath, types) {\n            var pattern = patternPath.value;\n            namedTypes.Pattern.assert(pattern);\n            if (namedTypes.Identifier.check(pattern)) {\n                if (hasOwn.call(types, pattern.name)) {\n                    types[pattern.name].push(patternPath);\n                } else {\n                    types[pattern.name] = [patternPath];\n                }\n            }\n        }\n        function addTypeParameter(parameterPath, types) {\n            var parameter = parameterPath.value;\n            FlowOrTSTypeParameterType.assert(parameter);\n            if (hasOwn.call(types, parameter.name)) {\n                types[parameter.name].push(parameterPath);\n            } else {\n                types[parameter.name] = [parameterPath];\n            }\n        }\n        Sp.lookup = function (name) {\n            for (var scope = this; scope; scope = scope.parent)\n                if (scope.declares(name))\n                    break;\n            return scope;\n        };\n        Sp.lookupType = function (name) {\n            for (var scope = this; scope; scope = scope.parent)\n                if (scope.declaresType(name))\n                    break;\n            return scope;\n        };\n        Sp.getGlobalScope = function () {\n            var scope = this;\n            while (!scope.isGlobal)\n                scope = scope.parent;\n            return scope;\n        };\n        return Scope;\n    };\n});\ndefine('skylark-asttypes/node-path',[\n    './types',\n    './path',\n    './scope'\n], function (typesPlugin, pathPlugin, scopePlugin) {\n    'use strict';\n    return function nodePathPlugin(fork) {\n        var types = fork.use(typesPlugin);\n        var n = types.namedTypes;\n        var b = types.builders;\n        var isNumber = types.builtInTypes.number;\n        var isArray = types.builtInTypes.array;\n        var Path = fork.use(pathPlugin);\n        var Scope = fork.use(scopePlugin);\n        const NodePath = function NodePath(value, parentPath, name) {\n            if (!(this instanceof NodePath)) {\n                throw new Error(\"NodePath constructor cannot be invoked without 'new'\");\n            }\n            Path.call(this, value, parentPath, name);\n        };\n        var NPp = NodePath.prototype = Object.create(Path.prototype, {\n            constructor: {\n                value: NodePath,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        Object.defineProperties(NPp, {\n            node: {\n                get: function () {\n                    Object.defineProperty(this, 'node', {\n                        configurable: true,\n                        value: this._computeNode()\n                    });\n                    return this.node;\n                }\n            },\n            parent: {\n                get: function () {\n                    Object.defineProperty(this, 'parent', {\n                        configurable: true,\n                        value: this._computeParent()\n                    });\n                    return this.parent;\n                }\n            },\n            scope: {\n                get: function () {\n                    Object.defineProperty(this, 'scope', {\n                        configurable: true,\n                        value: this._computeScope()\n                    });\n                    return this.scope;\n                }\n            }\n        });\n        NPp.replace = function () {\n            delete this.node;\n            delete this.parent;\n            delete this.scope;\n            return Path.prototype.replace.apply(this, arguments);\n        };\n        NPp.prune = function () {\n            var remainingNodePath = this.parent;\n            this.replace();\n            return cleanUpNodesAfterPrune(remainingNodePath);\n        };\n        NPp._computeNode = function () {\n            var value = this.value;\n            if (n.Node.check(value)) {\n                return value;\n            }\n            var pp = this.parentPath;\n            return pp && pp.node || null;\n        };\n        NPp._computeParent = function () {\n            var value = this.value;\n            var pp = this.parentPath;\n            if (!n.Node.check(value)) {\n                while (pp && !n.Node.check(pp.value)) {\n                    pp = pp.parentPath;\n                }\n                if (pp) {\n                    pp = pp.parentPath;\n                }\n            }\n            while (pp && !n.Node.check(pp.value)) {\n                pp = pp.parentPath;\n            }\n            return pp || null;\n        };\n        NPp._computeScope = function () {\n            var value = this.value;\n            var pp = this.parentPath;\n            var scope = pp && pp.scope;\n            if (n.Node.check(value) && Scope.isEstablishedBy(value)) {\n                scope = new Scope(this, scope);\n            }\n            return scope || null;\n        };\n        NPp.getValueProperty = function (name) {\n            return types.getFieldValue(this.value, name);\n        };\n        NPp.needsParens = function (assumeExpressionContext) {\n            var pp = this.parentPath;\n            if (!pp) {\n                return false;\n            }\n            var node = this.value;\n            if (!n.Expression.check(node)) {\n                return false;\n            }\n            if (node.type === 'Identifier') {\n                return false;\n            }\n            while (!n.Node.check(pp.value)) {\n                pp = pp.parentPath;\n                if (!pp) {\n                    return false;\n                }\n            }\n            var parent = pp.value;\n            switch (node.type) {\n            case 'UnaryExpression':\n            case 'SpreadElement':\n            case 'SpreadProperty':\n                return parent.type === 'MemberExpression' && this.name === 'object' && parent.object === node;\n            case 'BinaryExpression':\n            case 'LogicalExpression':\n                switch (parent.type) {\n                case 'CallExpression':\n                    return this.name === 'callee' && parent.callee === node;\n                case 'UnaryExpression':\n                case 'SpreadElement':\n                case 'SpreadProperty':\n                    return true;\n                case 'MemberExpression':\n                    return this.name === 'object' && parent.object === node;\n                case 'BinaryExpression':\n                case 'LogicalExpression': {\n                        const n = node;\n                        const po = parent.operator;\n                        const pp = PRECEDENCE[po];\n                        const no = n.operator;\n                        const np = PRECEDENCE[no];\n                        if (pp > np) {\n                            return true;\n                        }\n                        if (pp === np && this.name === 'right') {\n                            if (parent.right !== n) {\n                                throw new Error('Nodes must be equal');\n                            }\n                            return true;\n                        }\n                    }\n                default:\n                    return false;\n                }\n            case 'SequenceExpression':\n                switch (parent.type) {\n                case 'ForStatement':\n                    return false;\n                case 'ExpressionStatement':\n                    return this.name !== 'expression';\n                default:\n                    return true;\n                }\n            case 'YieldExpression':\n                switch (parent.type) {\n                case 'BinaryExpression':\n                case 'LogicalExpression':\n                case 'UnaryExpression':\n                case 'SpreadElement':\n                case 'SpreadProperty':\n                case 'CallExpression':\n                case 'MemberExpression':\n                case 'NewExpression':\n                case 'ConditionalExpression':\n                case 'YieldExpression':\n                    return true;\n                default:\n                    return false;\n                }\n            case 'Literal':\n                return parent.type === 'MemberExpression' && isNumber.check(node.value) && this.name === 'object' && parent.object === node;\n            case 'AssignmentExpression':\n            case 'ConditionalExpression':\n                switch (parent.type) {\n                case 'UnaryExpression':\n                case 'SpreadElement':\n                case 'SpreadProperty':\n                case 'BinaryExpression':\n                case 'LogicalExpression':\n                    return true;\n                case 'CallExpression':\n                    return this.name === 'callee' && parent.callee === node;\n                case 'ConditionalExpression':\n                    return this.name === 'test' && parent.test === node;\n                case 'MemberExpression':\n                    return this.name === 'object' && parent.object === node;\n                default:\n                    return false;\n                }\n            default:\n                if (parent.type === 'NewExpression' && this.name === 'callee' && parent.callee === node) {\n                    return containsCallExpression(node);\n                }\n            }\n            if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement())\n                return true;\n            return false;\n        };\n        function isBinary(node) {\n            return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);\n        }\n        function isUnaryLike(node) {\n            return n.UnaryExpression.check(node) || n.SpreadElement && n.SpreadElement.check(node) || n.SpreadProperty && n.SpreadProperty.check(node);\n        }\n        var PRECEDENCE = {};\n        [\n            ['||'],\n            ['&&'],\n            ['|'],\n            ['^'],\n            ['&'],\n            [\n                '==',\n                '===',\n                '!=',\n                '!=='\n            ],\n            [\n                '<',\n                '>',\n                '<=',\n                '>=',\n                'in',\n                'instanceof'\n            ],\n            [\n                '>>',\n                '<<',\n                '>>>'\n            ],\n            [\n                '+',\n                '-'\n            ],\n            [\n                '*',\n                '/',\n                '%'\n            ]\n        ].forEach(function (tier, i) {\n            tier.forEach(function (op) {\n                PRECEDENCE[op] = i;\n            });\n        });\n        function containsCallExpression(node) {\n            if (n.CallExpression.check(node)) {\n                return true;\n            }\n            if (isArray.check(node)) {\n                return node.some(containsCallExpression);\n            }\n            if (n.Node.check(node)) {\n                return types.someField(node, function (_name, child) {\n                    return containsCallExpression(child);\n                });\n            }\n            return false;\n        }\n        NPp.canBeFirstInStatement = function () {\n            var node = this.node;\n            return !n.FunctionExpression.check(node) && !n.ObjectExpression.check(node);\n        };\n        NPp.firstInStatement = function () {\n            return firstInStatement(this);\n        };\n        function firstInStatement(path) {\n            for (var node, parent; path.parent; path = path.parent) {\n                node = path.node;\n                parent = path.parent.node;\n                if (n.BlockStatement.check(parent) && path.parent.name === 'body' && path.name === 0) {\n                    if (parent.body[0] !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    return true;\n                }\n                if (n.ExpressionStatement.check(parent) && path.name === 'expression') {\n                    if (parent.expression !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    return true;\n                }\n                if (n.SequenceExpression.check(parent) && path.parent.name === 'expressions' && path.name === 0) {\n                    if (parent.expressions[0] !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    continue;\n                }\n                if (n.CallExpression.check(parent) && path.name === 'callee') {\n                    if (parent.callee !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    continue;\n                }\n                if (n.MemberExpression.check(parent) && path.name === 'object') {\n                    if (parent.object !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    continue;\n                }\n                if (n.ConditionalExpression.check(parent) && path.name === 'test') {\n                    if (parent.test !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    continue;\n                }\n                if (isBinary(parent) && path.name === 'left') {\n                    if (parent.left !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    continue;\n                }\n                if (n.UnaryExpression.check(parent) && !parent.prefix && path.name === 'argument') {\n                    if (parent.argument !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        function cleanUpNodesAfterPrune(remainingNodePath) {\n            if (n.VariableDeclaration.check(remainingNodePath.node)) {\n                var declarations = remainingNodePath.get('declarations').value;\n                if (!declarations || declarations.length === 0) {\n                    return remainingNodePath.prune();\n                }\n            } else if (n.ExpressionStatement.check(remainingNodePath.node)) {\n                if (!remainingNodePath.get('expression').value) {\n                    return remainingNodePath.prune();\n                }\n            } else if (n.IfStatement.check(remainingNodePath.node)) {\n                cleanUpIfStatementAfterPrune(remainingNodePath);\n            }\n            return remainingNodePath;\n        }\n        function cleanUpIfStatementAfterPrune(ifStatement) {\n            var testExpression = ifStatement.get('test').value;\n            var alternate = ifStatement.get('alternate').value;\n            var consequent = ifStatement.get('consequent').value;\n            if (!consequent && !alternate) {\n                var testExpressionStatement = b.expressionStatement(testExpression);\n                ifStatement.replace(testExpressionStatement);\n            } else if (!consequent && alternate) {\n                var negatedTestExpression = b.unaryExpression('!', testExpression, true);\n                if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {\n                    negatedTestExpression = testExpression.argument;\n                }\n                ifStatement.get('test').replace(negatedTestExpression);\n                ifStatement.get('consequent').replace(alternate);\n                ifStatement.get('alternate').replace();\n            }\n        }\n        return NodePath;\n    };\n});\ndefine('skylark-asttypes/path-visitor',[\n    './types',\n    './node-path'\n], function (typesPlugin, nodePathPlugin) {\n    'use strict';\n    var hasOwn = Object.prototype.hasOwnProperty;\n    return function pathVisitorPlugin(fork) {\n        var types = fork.use(typesPlugin);\n        var NodePath = fork.use(nodePathPlugin);\n        var isArray = types.builtInTypes.array;\n        var isObject = types.builtInTypes.object;\n        var isFunction = types.builtInTypes.function;\n        var undefined;\n        const PathVisitor = function PathVisitor() {\n            if (!(this instanceof PathVisitor)) {\n                throw new Error(\"PathVisitor constructor cannot be invoked without 'new'\");\n            }\n            this._reusableContextStack = [];\n            this._methodNameTable = computeMethodNameTable(this);\n            this._shouldVisitComments = hasOwn.call(this._methodNameTable, 'Block') || hasOwn.call(this._methodNameTable, 'Line');\n            this.Context = makeContextConstructor(this);\n            this._visiting = false;\n            this._changeReported = false;\n        };\n        function computeMethodNameTable(visitor) {\n            var typeNames = Object.create(null);\n            for (var methodName in visitor) {\n                if (/^visit[A-Z]/.test(methodName)) {\n                    typeNames[methodName.slice('visit'.length)] = true;\n                }\n            }\n            var supertypeTable = types.computeSupertypeLookupTable(typeNames);\n            var methodNameTable = Object.create(null);\n            var typeNameKeys = Object.keys(supertypeTable);\n            var typeNameCount = typeNameKeys.length;\n            for (var i = 0; i < typeNameCount; ++i) {\n                var typeName = typeNameKeys[i];\n                methodName = 'visit' + supertypeTable[typeName];\n                if (isFunction.check(visitor[methodName])) {\n                    methodNameTable[typeName] = methodName;\n                }\n            }\n            return methodNameTable;\n        }\n        PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {\n            if (methods instanceof PathVisitor) {\n                return methods;\n            }\n            if (!isObject.check(methods)) {\n                return new PathVisitor();\n            }\n            const Visitor = function Visitor() {\n                if (!(this instanceof Visitor)) {\n                    throw new Error(\"Visitor constructor cannot be invoked without 'new'\");\n                }\n                PathVisitor.call(this);\n            };\n            var Vp = Visitor.prototype = Object.create(PVp);\n            Vp.constructor = Visitor;\n            extend(Vp, methods);\n            extend(Visitor, PathVisitor);\n            isFunction.assert(Visitor.fromMethodsObject);\n            isFunction.assert(Visitor.visit);\n            return new Visitor();\n        };\n        function extend(target, source) {\n            for (var property in source) {\n                if (hasOwn.call(source, property)) {\n                    target[property] = source[property];\n                }\n            }\n            return target;\n        }\n        PathVisitor.visit = function visit(node, methods) {\n            return PathVisitor.fromMethodsObject(methods).visit(node);\n        };\n        var PVp = PathVisitor.prototype;\n        PVp.visit = function () {\n            if (this._visiting) {\n                throw new Error('Recursively calling visitor.visit(path) resets visitor state. ' + 'Try this.visit(path) or this.traverse(path) instead.');\n            }\n            this._visiting = true;\n            this._changeReported = false;\n            this._abortRequested = false;\n            var argc = arguments.length;\n            var args = new Array(argc);\n            for (var i = 0; i < argc; ++i) {\n                args[i] = arguments[i];\n            }\n            if (!(args[0] instanceof NodePath)) {\n                args[0] = new NodePath({ root: args[0] }).get('root');\n            }\n            this.reset.apply(this, args);\n            var didNotThrow;\n            try {\n                var root = this.visitWithoutReset(args[0]);\n                didNotThrow = true;\n            } finally {\n                this._visiting = false;\n                if (!didNotThrow && this._abortRequested) {\n                    return args[0].value;\n                }\n            }\n            return root;\n        };\n        PVp.AbortRequest = function AbortRequest() {\n        };\n        PVp.abort = function () {\n            var visitor = this;\n            visitor._abortRequested = true;\n            var request = new visitor.AbortRequest();\n            request.cancel = function () {\n                visitor._abortRequested = false;\n            };\n            throw request;\n        };\n        PVp.reset = function (_path) {\n        };\n        PVp.visitWithoutReset = function (path) {\n            if (this instanceof this.Context) {\n                return this.visitor.visitWithoutReset(path);\n            }\n            if (!(path instanceof NodePath)) {\n                throw new Error('');\n            }\n            var value = path.value;\n            var methodName = value && typeof value === 'object' && typeof value.type === 'string' && this._methodNameTable[value.type];\n            if (methodName) {\n                var context = this.acquireContext(path);\n                try {\n                    return context.invokeVisitorMethod(methodName);\n                } finally {\n                    this.releaseContext(context);\n                }\n            } else {\n                return visitChildren(path, this);\n            }\n        };\n        function visitChildren(path, visitor) {\n            if (!(path instanceof NodePath)) {\n                throw new Error('');\n            }\n            if (!(visitor instanceof PathVisitor)) {\n                throw new Error('');\n            }\n            var value = path.value;\n            if (isArray.check(value)) {\n                path.each(visitor.visitWithoutReset, visitor);\n            } else if (!isObject.check(value)) {\n            } else {\n                var childNames = types.getFieldNames(value);\n                if (visitor._shouldVisitComments && value.comments && childNames.indexOf('comments') < 0) {\n                    childNames.push('comments');\n                }\n                var childCount = childNames.length;\n                var childPaths = [];\n                for (var i = 0; i < childCount; ++i) {\n                    var childName = childNames[i];\n                    if (!hasOwn.call(value, childName)) {\n                        value[childName] = types.getFieldValue(value, childName);\n                    }\n                    childPaths.push(path.get(childName));\n                }\n                for (var i = 0; i < childCount; ++i) {\n                    visitor.visitWithoutReset(childPaths[i]);\n                }\n            }\n            return path.value;\n        }\n        PVp.acquireContext = function (path) {\n            if (this._reusableContextStack.length === 0) {\n                return new this.Context(path);\n            }\n            return this._reusableContextStack.pop().reset(path);\n        };\n        PVp.releaseContext = function (context) {\n            if (!(context instanceof this.Context)) {\n                throw new Error('');\n            }\n            this._reusableContextStack.push(context);\n            context.currentPath = null;\n        };\n        PVp.reportChanged = function () {\n            this._changeReported = true;\n        };\n        PVp.wasChangeReported = function () {\n            return this._changeReported;\n        };\n        function makeContextConstructor(visitor) {\n            function Context(path) {\n                if (!(this instanceof Context)) {\n                    throw new Error('');\n                }\n                if (!(this instanceof PathVisitor)) {\n                    throw new Error('');\n                }\n                if (!(path instanceof NodePath)) {\n                    throw new Error('');\n                }\n                Object.defineProperty(this, 'visitor', {\n                    value: visitor,\n                    writable: false,\n                    enumerable: true,\n                    configurable: false\n                });\n                this.currentPath = path;\n                this.needToCallTraverse = true;\n                Object.seal(this);\n            }\n            if (!(visitor instanceof PathVisitor)) {\n                throw new Error('');\n            }\n            var Cp = Context.prototype = Object.create(visitor);\n            Cp.constructor = Context;\n            extend(Cp, sharedContextProtoMethods);\n            return Context;\n        }\n        var sharedContextProtoMethods = Object.create(null);\n        sharedContextProtoMethods.reset = function reset(path) {\n            if (!(this instanceof this.Context)) {\n                throw new Error('');\n            }\n            if (!(path instanceof NodePath)) {\n                throw new Error('');\n            }\n            this.currentPath = path;\n            this.needToCallTraverse = true;\n            return this;\n        };\n        sharedContextProtoMethods.invokeVisitorMethod = function invokeVisitorMethod(methodName) {\n            if (!(this instanceof this.Context)) {\n                throw new Error('');\n            }\n            if (!(this.currentPath instanceof NodePath)) {\n                throw new Error('');\n            }\n            var result = this.visitor[methodName].call(this, this.currentPath);\n            if (result === false) {\n                this.needToCallTraverse = false;\n            } else if (result !== undefined) {\n                this.currentPath = this.currentPath.replace(result)[0];\n                if (this.needToCallTraverse) {\n                    this.traverse(this.currentPath);\n                }\n            }\n            if (this.needToCallTraverse !== false) {\n                throw new Error('Must either call this.traverse or return false in ' + methodName);\n            }\n            var path = this.currentPath;\n            return path && path.value;\n        };\n        sharedContextProtoMethods.traverse = function traverse(path, newVisitor) {\n            if (!(this instanceof this.Context)) {\n                throw new Error('');\n            }\n            if (!(path instanceof NodePath)) {\n                throw new Error('');\n            }\n            if (!(this.currentPath instanceof NodePath)) {\n                throw new Error('');\n            }\n            this.needToCallTraverse = false;\n            return visitChildren(path, PathVisitor.fromMethodsObject(newVisitor || this.visitor));\n        };\n        sharedContextProtoMethods.visit = function visit(path, newVisitor) {\n            if (!(this instanceof this.Context)) {\n                throw new Error('');\n            }\n            if (!(path instanceof NodePath)) {\n                throw new Error('');\n            }\n            if (!(this.currentPath instanceof NodePath)) {\n                throw new Error('');\n            }\n            this.needToCallTraverse = false;\n            return PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path);\n        };\n        sharedContextProtoMethods.reportChanged = function reportChanged() {\n            this.visitor.reportChanged();\n        };\n        sharedContextProtoMethods.abort = function abort() {\n            this.needToCallTraverse = false;\n            this.visitor.abort();\n        };\n        return PathVisitor;\n    };\n});\ndefine('skylark-asttypes/equiv',['./types'], function (typesPlugin) {\n    'use strict';\n    return function (fork) {\n        var types = fork.use(typesPlugin);\n        var getFieldNames = types.getFieldNames;\n        var getFieldValue = types.getFieldValue;\n        var isArray = types.builtInTypes.array;\n        var isObject = types.builtInTypes.object;\n        var isDate = types.builtInTypes.Date;\n        var isRegExp = types.builtInTypes.RegExp;\n        var hasOwn = Object.prototype.hasOwnProperty;\n        function astNodesAreEquivalent(a, b, problemPath) {\n            if (isArray.check(problemPath)) {\n                problemPath.length = 0;\n            } else {\n                problemPath = null;\n            }\n            return areEquivalent(a, b, problemPath);\n        }\n        astNodesAreEquivalent.assert = function (a, b) {\n            var problemPath = [];\n            if (!astNodesAreEquivalent(a, b, problemPath)) {\n                if (problemPath.length === 0) {\n                    if (a !== b) {\n                        throw new Error('Nodes must be equal');\n                    }\n                } else {\n                    throw new Error('Nodes differ in the following path: ' + problemPath.map(subscriptForProperty).join(''));\n                }\n            }\n        };\n        function subscriptForProperty(property) {\n            if (/[_$a-z][_$a-z0-9]*/i.test(property)) {\n                return '.' + property;\n            }\n            return '[' + JSON.stringify(property) + ']';\n        }\n        function areEquivalent(a, b, problemPath) {\n            if (a === b) {\n                return true;\n            }\n            if (isArray.check(a)) {\n                return arraysAreEquivalent(a, b, problemPath);\n            }\n            if (isObject.check(a)) {\n                return objectsAreEquivalent(a, b, problemPath);\n            }\n            if (isDate.check(a)) {\n                return isDate.check(b) && +a === +b;\n            }\n            if (isRegExp.check(a)) {\n                return isRegExp.check(b) && (a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.ignoreCase === b.ignoreCase);\n            }\n            return a == b;\n        }\n        function arraysAreEquivalent(a, b, problemPath) {\n            isArray.assert(a);\n            var aLength = a.length;\n            if (!isArray.check(b) || b.length !== aLength) {\n                if (problemPath) {\n                    problemPath.push('length');\n                }\n                return false;\n            }\n            for (var i = 0; i < aLength; ++i) {\n                if (problemPath) {\n                    problemPath.push(i);\n                }\n                if (i in a !== i in b) {\n                    return false;\n                }\n                if (!areEquivalent(a[i], b[i], problemPath)) {\n                    return false;\n                }\n                if (problemPath) {\n                    var problemPathTail = problemPath.pop();\n                    if (problemPathTail !== i) {\n                        throw new Error('' + problemPathTail);\n                    }\n                }\n            }\n            return true;\n        }\n        function objectsAreEquivalent(a, b, problemPath) {\n            isObject.assert(a);\n            if (!isObject.check(b)) {\n                return false;\n            }\n            if (a.type !== b.type) {\n                if (problemPath) {\n                    problemPath.push('type');\n                }\n                return false;\n            }\n            var aNames = getFieldNames(a);\n            var aNameCount = aNames.length;\n            var bNames = getFieldNames(b);\n            var bNameCount = bNames.length;\n            if (aNameCount === bNameCount) {\n                for (var i = 0; i < aNameCount; ++i) {\n                    var name = aNames[i];\n                    var aChild = getFieldValue(a, name);\n                    var bChild = getFieldValue(b, name);\n                    if (problemPath) {\n                        problemPath.push(name);\n                    }\n                    if (!areEquivalent(aChild, bChild, problemPath)) {\n                        return false;\n                    }\n                    if (problemPath) {\n                        var problemPathTail = problemPath.pop();\n                        if (problemPathTail !== name) {\n                            throw new Error('' + problemPathTail);\n                        }\n                    }\n                }\n                return true;\n            }\n            if (!problemPath) {\n                return false;\n            }\n            var seenNames = Object.create(null);\n            for (i = 0; i < aNameCount; ++i) {\n                seenNames[aNames[i]] = true;\n            }\n            for (i = 0; i < bNameCount; ++i) {\n                name = bNames[i];\n                if (!hasOwn.call(seenNames, name)) {\n                    problemPath.push(name);\n                    return false;\n                }\n                delete seenNames[name];\n            }\n            for (name in seenNames) {\n                problemPath.push(name);\n                break;\n            }\n            return false;\n        }\n        return astNodesAreEquivalent;\n    };\n});\ndefine('skylark-asttypes/fork',[\n    './types',\n    './path-visitor',\n    './equiv',\n    './path',\n    './node-path'\n], function (typesPlugin, pathVisitorPlugin, equivPlugin, pathPlugin, nodePathPlugin) {\n    'use strict';\n    function createFork() {\n        const used = [];\n        const usedResult = [];\n        function use(plugin) {\n            var idx = used.indexOf(plugin);\n            if (idx === -1) {\n                idx = used.length;\n                used.push(plugin);\n                usedResult[idx] = plugin(fork);\n            }\n            return usedResult[idx];\n        }\n        var fork = { use };\n        return fork;\n    }\n    return function (plugins) {\n        const fork = createFork();\n        const types = fork.use(typesPlugin);\n        plugins.forEach(fork.use);\n        types.finalize();\n        const PathVisitor = fork.use(pathVisitorPlugin);\n        return {\n            Type: types.Type,\n            builtInTypes: types.builtInTypes,\n            namedTypes: types.namedTypes,\n            builders: types.builders,\n            defineMethod: types.defineMethod,\n            getFieldNames: types.getFieldNames,\n            getFieldValue: types.getFieldValue,\n            eachField: types.eachField,\n            someField: types.someField,\n            getSupertypeNames: types.getSupertypeNames,\n            getBuilderName: types.getBuilderName,\n            astNodesAreEquivalent: fork.use(equivPlugin),\n            finalize: types.finalize,\n            Path: fork.use(pathPlugin),\n            NodePath: fork.use(nodePathPlugin),\n            PathVisitor,\n            use: fork.use,\n            visit: PathVisitor.visit\n        };\n    };\n    ;\n\n});\ndefine('skylark-asttypes/def/operators/core',[],function () {\n    'use strict';\n    return function () {\n        return {\n            BinaryOperators: [\n                '==',\n                '!=',\n                '===',\n                '!==',\n                '<',\n                '<=',\n                '>',\n                '>=',\n                '<<',\n                '>>',\n                '>>>',\n                '+',\n                '-',\n                '*',\n                '/',\n                '%',\n                '&',\n                '|',\n                '^',\n                'in',\n                'instanceof'\n            ],\n            AssignmentOperators: [\n                '=',\n                '+=',\n                '-=',\n                '*=',\n                '/=',\n                '%=',\n                '<<=',\n                '>>=',\n                '>>>=',\n                '|=',\n                '^=',\n                '&='\n            ],\n            LogicalOperators: [\n                '||',\n                '&&'\n            ]\n        };\n    };\n});\ndefine('skylark-asttypes/def/operators/es2016',['./core'], function (coreOpsDef) {\n    'use strict';\n    return function (fork) {\n        const result = fork.use(coreOpsDef);\n        if (result.BinaryOperators.indexOf('**') < 0) {\n            result.BinaryOperators.push('**');\n        }\n        if (result.AssignmentOperators.indexOf('**=') < 0) {\n            result.AssignmentOperators.push('**=');\n        }\n        return result;\n    };\n});\ndefine('skylark-asttypes/def/operators/es2020',['./es2016'], function (es2016OpsDef) {\n    'use strict';\n    return function (fork) {\n        const result = fork.use(es2016OpsDef);\n        if (result.LogicalOperators.indexOf('??') < 0) {\n            result.LogicalOperators.push('??');\n        }\n        return result;\n    };\n});\ndefine('skylark-asttypes/def/operators/es2021',['./es2020'], function (es2020OpsDef) {\n    'use strict';\n    return function (fork) {\n        const result = fork.use(es2020OpsDef);\n        result.LogicalOperators.forEach(op => {\n            const assignOp = op + '=';\n            if (result.AssignmentOperators.indexOf(assignOp) < 0) {\n                result.AssignmentOperators.push(assignOp);\n            }\n        });\n        return result;\n    };\n});\ndefine('skylark-asttypes/def/core',[\n    './operators/core',\n    '../types'\n], function (coreOpsDef, typesPlugin) {\n    'use strict';\n    return function (fork) {\n        var types = fork.use(typesPlugin);\n        var Type = types.Type;\n        var def = Type.def;\n        var or = Type.or;\n        var shared = fork.use(sharedPlugin);\n        var defaults = shared.defaults;\n        var geq = shared.geq;\n        const {BinaryOperators, AssignmentOperators, LogicalOperators} = fork.use(coreOpsDef);\n        def('Printable').field('loc', or(def('SourceLocation'), null), defaults['null'], true);\n        def('Node').bases('Printable').field('type', String).field('comments', or([def('Comment')], null), defaults['null'], true);\n        def('SourceLocation').field('start', def('Position')).field('end', def('Position')).field('source', or(String, null), defaults['null']);\n        def('Position').field('line', geq(1)).field('column', geq(0));\n        def('File').bases('Node').build('program', 'name').field('program', def('Program')).field('name', or(String, null), defaults['null']);\n        def('Program').bases('Node').build('body').field('body', [def('Statement')]);\n        def('Function').bases('Node').field('id', or(def('Identifier'), null), defaults['null']).field('params', [def('Pattern')]).field('body', def('BlockStatement')).field('generator', Boolean, defaults['false']).field('async', Boolean, defaults['false']);\n        def('Statement').bases('Node');\n        def('EmptyStatement').bases('Statement').build();\n        def('BlockStatement').bases('Statement').build('body').field('body', [def('Statement')]);\n        def('ExpressionStatement').bases('Statement').build('expression').field('expression', def('Expression'));\n        def('IfStatement').bases('Statement').build('test', 'consequent', 'alternate').field('test', def('Expression')).field('consequent', def('Statement')).field('alternate', or(def('Statement'), null), defaults['null']);\n        def('LabeledStatement').bases('Statement').build('label', 'body').field('label', def('Identifier')).field('body', def('Statement'));\n        def('BreakStatement').bases('Statement').build('label').field('label', or(def('Identifier'), null), defaults['null']);\n        def('ContinueStatement').bases('Statement').build('label').field('label', or(def('Identifier'), null), defaults['null']);\n        def('WithStatement').bases('Statement').build('object', 'body').field('object', def('Expression')).field('body', def('Statement'));\n        def('SwitchStatement').bases('Statement').build('discriminant', 'cases', 'lexical').field('discriminant', def('Expression')).field('cases', [def('SwitchCase')]).field('lexical', Boolean, defaults['false']);\n        def('ReturnStatement').bases('Statement').build('argument').field('argument', or(def('Expression'), null));\n        def('ThrowStatement').bases('Statement').build('argument').field('argument', def('Expression'));\n        def('TryStatement').bases('Statement').build('block', 'handler', 'finalizer').field('block', def('BlockStatement')).field('handler', or(def('CatchClause'), null), function () {\n            return this.handlers && this.handlers[0] || null;\n        }).field('handlers', [def('CatchClause')], function () {\n            return this.handler ? [this.handler] : [];\n        }, true).field('guardedHandlers', [def('CatchClause')], defaults.emptyArray).field('finalizer', or(def('BlockStatement'), null), defaults['null']);\n        def('CatchClause').bases('Node').build('param', 'guard', 'body').field('param', def('Pattern')).field('guard', or(def('Expression'), null), defaults['null']).field('body', def('BlockStatement'));\n        def('WhileStatement').bases('Statement').build('test', 'body').field('test', def('Expression')).field('body', def('Statement'));\n        def('DoWhileStatement').bases('Statement').build('body', 'test').field('body', def('Statement')).field('test', def('Expression'));\n        def('ForStatement').bases('Statement').build('init', 'test', 'update', 'body').field('init', or(def('VariableDeclaration'), def('Expression'), null)).field('test', or(def('Expression'), null)).field('update', or(def('Expression'), null)).field('body', def('Statement'));\n        def('ForInStatement').bases('Statement').build('left', 'right', 'body').field('left', or(def('VariableDeclaration'), def('Expression'))).field('right', def('Expression')).field('body', def('Statement'));\n        def('DebuggerStatement').bases('Statement').build();\n        def('Declaration').bases('Statement');\n        def('FunctionDeclaration').bases('Function', 'Declaration').build('id', 'params', 'body').field('id', def('Identifier'));\n        def('FunctionExpression').bases('Function', 'Expression').build('id', 'params', 'body');\n        def('VariableDeclaration').bases('Declaration').build('kind', 'declarations').field('kind', or('var', 'let', 'const')).field('declarations', [def('VariableDeclarator')]);\n        def('VariableDeclarator').bases('Node').build('id', 'init').field('id', def('Pattern')).field('init', or(def('Expression'), null), defaults['null']);\n        def('Expression').bases('Node');\n        def('ThisExpression').bases('Expression').build();\n        def('ArrayExpression').bases('Expression').build('elements').field('elements', [or(def('Expression'), null)]);\n        def('ObjectExpression').bases('Expression').build('properties').field('properties', [def('Property')]);\n        def('Property').bases('Node').build('kind', 'key', 'value').field('kind', or('init', 'get', 'set')).field('key', or(def('Literal'), def('Identifier'))).field('value', def('Expression'));\n        def('SequenceExpression').bases('Expression').build('expressions').field('expressions', [def('Expression')]);\n        var UnaryOperator = or('-', '+', '!', '~', 'typeof', 'void', 'delete');\n        def('UnaryExpression').bases('Expression').build('operator', 'argument', 'prefix').field('operator', UnaryOperator).field('argument', def('Expression')).field('prefix', Boolean, defaults['true']);\n        const BinaryOperator = or(...BinaryOperators);\n        def('BinaryExpression').bases('Expression').build('operator', 'left', 'right').field('operator', BinaryOperator).field('left', def('Expression')).field('right', def('Expression'));\n        const AssignmentOperator = or(...AssignmentOperators);\n        def('AssignmentExpression').bases('Expression').build('operator', 'left', 'right').field('operator', AssignmentOperator).field('left', or(def('Pattern'), def('MemberExpression'))).field('right', def('Expression'));\n        var UpdateOperator = or('++', '--');\n        def('UpdateExpression').bases('Expression').build('operator', 'argument', 'prefix').field('operator', UpdateOperator).field('argument', def('Expression')).field('prefix', Boolean);\n        var LogicalOperator = or(...LogicalOperators);\n        def('LogicalExpression').bases('Expression').build('operator', 'left', 'right').field('operator', LogicalOperator).field('left', def('Expression')).field('right', def('Expression'));\n        def('ConditionalExpression').bases('Expression').build('test', 'consequent', 'alternate').field('test', def('Expression')).field('consequent', def('Expression')).field('alternate', def('Expression'));\n        def('NewExpression').bases('Expression').build('callee', 'arguments').field('callee', def('Expression')).field('arguments', [def('Expression')]);\n        def('CallExpression').bases('Expression').build('callee', 'arguments').field('callee', def('Expression')).field('arguments', [def('Expression')]);\n        def('MemberExpression').bases('Expression').build('object', 'property', 'computed').field('object', def('Expression')).field('property', or(def('Identifier'), def('Expression'))).field('computed', Boolean, function () {\n            var type = this.property.type;\n            if (type === 'Literal' || type === 'MemberExpression' || type === 'BinaryExpression') {\n                return true;\n            }\n            return false;\n        });\n        def('Pattern').bases('Node');\n        def('SwitchCase').bases('Node').build('test', 'consequent').field('test', or(def('Expression'), null)).field('consequent', [def('Statement')]);\n        def('Identifier').bases('Expression', 'Pattern').build('name').field('name', String).field('optional', Boolean, defaults['false']);\n        def('Literal').bases('Expression').build('value').field('value', or(String, Boolean, null, Number, RegExp, BigInt));\n        def('Comment').bases('Printable').field('value', String).field('leading', Boolean, defaults['true']).field('trailing', Boolean, defaults['false']);\n    };\n});\ndefine('skylark-asttypes/shared',['./types'], function (typesPlugin) {\n    'use strict';\n    return function (fork) {\n        var types = fork.use(typesPlugin);\n        var Type = types.Type;\n        var builtin = types.builtInTypes;\n        var isNumber = builtin.number;\n        function geq(than) {\n            return Type.from(value => isNumber.check(value) && value >= than, isNumber + ' >= ' + than);\n        }\n        ;\n        const defaults = {\n            'null': function () {\n                return null;\n            },\n            'emptyArray': function () {\n                return [];\n            },\n            'false': function () {\n                return false;\n            },\n            'true': function () {\n                return true;\n            },\n            'undefined': function () {\n            },\n            'use strict': function () {\n                return 'use strict';\n            }\n        };\n        var naiveIsPrimitive = Type.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined);\n        const isPrimitive = Type.from(value => {\n            if (value === null)\n                return true;\n            var type = typeof value;\n            if (type === 'object' || type === 'function') {\n                return false;\n            }\n            return true;\n        }, naiveIsPrimitive.toString());\n        return {\n            geq,\n            defaults,\n            isPrimitive\n        };\n    };\n\n});\ndefine('skylark-asttypes/def/es6',[\n    './core',\n    '../types',\n    '../shared'\n], function (coreDef, typesPlugin, sharedPlugin) {\n    'use strict';\n    return function (fork) {\n        fork.use(coreDef);\n        const types = fork.use(typesPlugin);\n        const def = types.Type.def;\n        const or = types.Type.or;\n        const defaults = fork.use(sharedPlugin).defaults;\n        def('Function').field('generator', Boolean, defaults['false']).field('expression', Boolean, defaults['false']).field('defaults', [or(def('Expression'), null)], defaults.emptyArray).field('rest', or(def('Identifier'), null), defaults['null']);\n        def('RestElement').bases('Pattern').build('argument').field('argument', def('Pattern')).field('typeAnnotation', or(def('TypeAnnotation'), def('TSTypeAnnotation'), null), defaults['null']);\n        def('SpreadElementPattern').bases('Pattern').build('argument').field('argument', def('Pattern'));\n        def('FunctionDeclaration').build('id', 'params', 'body', 'generator', 'expression').field('id', or(def('Identifier'), null));\n        def('FunctionExpression').build('id', 'params', 'body', 'generator', 'expression');\n        def('ArrowFunctionExpression').bases('Function', 'Expression').build('params', 'body', 'expression').field('id', null, defaults['null']).field('body', or(def('BlockStatement'), def('Expression'))).field('generator', false, defaults['false']);\n        def('ForOfStatement').bases('Statement').build('left', 'right', 'body').field('left', or(def('VariableDeclaration'), def('Pattern'))).field('right', def('Expression')).field('body', def('Statement'));\n        def('YieldExpression').bases('Expression').build('argument', 'delegate').field('argument', or(def('Expression'), null)).field('delegate', Boolean, defaults['false']);\n        def('GeneratorExpression').bases('Expression').build('body', 'blocks', 'filter').field('body', def('Expression')).field('blocks', [def('ComprehensionBlock')]).field('filter', or(def('Expression'), null));\n        def('ComprehensionExpression').bases('Expression').build('body', 'blocks', 'filter').field('body', def('Expression')).field('blocks', [def('ComprehensionBlock')]).field('filter', or(def('Expression'), null));\n        def('ComprehensionBlock').bases('Node').build('left', 'right', 'each').field('left', def('Pattern')).field('right', def('Expression')).field('each', Boolean);\n        def('Property').field('key', or(def('Literal'), def('Identifier'), def('Expression'))).field('value', or(def('Expression'), def('Pattern'))).field('method', Boolean, defaults['false']).field('shorthand', Boolean, defaults['false']).field('computed', Boolean, defaults['false']);\n        def('ObjectProperty').field('shorthand', Boolean, defaults['false']);\n        def('PropertyPattern').bases('Pattern').build('key', 'pattern').field('key', or(def('Literal'), def('Identifier'), def('Expression'))).field('pattern', def('Pattern')).field('computed', Boolean, defaults['false']);\n        def('ObjectPattern').bases('Pattern').build('properties').field('properties', [or(def('PropertyPattern'), def('Property'))]);\n        def('ArrayPattern').bases('Pattern').build('elements').field('elements', [or(def('Pattern'), null)]);\n        def('SpreadElement').bases('Node').build('argument').field('argument', def('Expression'));\n        def('ArrayExpression').field('elements', [or(def('Expression'), def('SpreadElement'), def('RestElement'), null)]);\n        def('NewExpression').field('arguments', [or(def('Expression'), def('SpreadElement'))]);\n        def('CallExpression').field('arguments', [or(def('Expression'), def('SpreadElement'))]);\n        def('AssignmentPattern').bases('Pattern').build('left', 'right').field('left', def('Pattern')).field('right', def('Expression'));\n        def('MethodDefinition').bases('Declaration').build('kind', 'key', 'value', 'static').field('kind', or('constructor', 'method', 'get', 'set')).field('key', def('Expression')).field('value', def('Function')).field('computed', Boolean, defaults['false']).field('static', Boolean, defaults['false']);\n        const ClassBodyElement = or(def('MethodDefinition'), def('VariableDeclarator'), def('ClassPropertyDefinition'), def('ClassProperty'), def('StaticBlock'));\n        def('ClassProperty').bases('Declaration').build('key').field('key', or(def('Literal'), def('Identifier'), def('Expression'))).field('computed', Boolean, defaults['false']);\n        def('ClassPropertyDefinition').bases('Declaration').build('definition').field('definition', ClassBodyElement);\n        def('ClassBody').bases('Declaration').build('body').field('body', [ClassBodyElement]);\n        def('ClassDeclaration').bases('Declaration').build('id', 'body', 'superClass').field('id', or(def('Identifier'), null)).field('body', def('ClassBody')).field('superClass', or(def('Expression'), null), defaults['null']);\n        def('ClassExpression').bases('Expression').build('id', 'body', 'superClass').field('id', or(def('Identifier'), null), defaults['null']).field('body', def('ClassBody')).field('superClass', or(def('Expression'), null), defaults['null']);\n        def('Super').bases('Expression').build();\n        def('Specifier').bases('Node');\n        def('ModuleSpecifier').bases('Specifier').field('local', or(def('Identifier'), null), defaults['null']).field('id', or(def('Identifier'), null), defaults['null']).field('name', or(def('Identifier'), null), defaults['null']);\n        def('ImportSpecifier').bases('ModuleSpecifier').build('imported', 'local').field('imported', def('Identifier'));\n        def('ImportDefaultSpecifier').bases('ModuleSpecifier').build('local');\n        def('ImportNamespaceSpecifier').bases('ModuleSpecifier').build('local');\n        def('ImportDeclaration').bases('Declaration').build('specifiers', 'source', 'importKind').field('specifiers', [or(def('ImportSpecifier'), def('ImportNamespaceSpecifier'), def('ImportDefaultSpecifier'))], defaults.emptyArray).field('source', def('Literal')).field('importKind', or('value', 'type'), function () {\n            return 'value';\n        });\n        def('ExportNamedDeclaration').bases('Declaration').build('declaration', 'specifiers', 'source').field('declaration', or(def('Declaration'), null)).field('specifiers', [def('ExportSpecifier')], defaults.emptyArray).field('source', or(def('Literal'), null), defaults['null']);\n        def('ExportSpecifier').bases('ModuleSpecifier').build('local', 'exported').field('exported', def('Identifier'));\n        def('ExportDefaultDeclaration').bases('Declaration').build('declaration').field('declaration', or(def('Declaration'), def('Expression')));\n        def('ExportAllDeclaration').bases('Declaration').build('source').field('source', def('Literal'));\n        def('TaggedTemplateExpression').bases('Expression').build('tag', 'quasi').field('tag', def('Expression')).field('quasi', def('TemplateLiteral'));\n        def('TemplateLiteral').bases('Expression').build('quasis', 'expressions').field('quasis', [def('TemplateElement')]).field('expressions', [def('Expression')]);\n        def('TemplateElement').bases('Node').build('value', 'tail').field('value', {\n            'cooked': String,\n            'raw': String\n        }).field('tail', Boolean);\n        def('MetaProperty').bases('Expression').build('meta', 'property').field('meta', def('Identifier')).field('property', def('Identifier'));\n    };\n});\ndefine('skylark-asttypes/def/es2016',[\n    './operators/es2016',\n    './es6'\n], function (es2016OpsDef, es6Def) {\n    'use strict';\n    return function (fork) {\n        fork.use(es2016OpsDef);\n        fork.use(es6Def);\n    };\n});\ndefine('skylark-asttypes/def/es2017',[\n    './es2016',\n    '../types',\n    '../shared'\n], function (es2016Def, typesPlugin, sharedPlugin) {\n    'use strict';\n    return function (fork) {\n        fork.use(es2016Def);\n        const types = fork.use(typesPlugin);\n        const def = types.Type.def;\n        const defaults = fork.use(sharedPlugin).defaults;\n        def('Function').field('async', Boolean, defaults['false']);\n        def('AwaitExpression').bases('Expression').build('argument').field('argument', def('Expression'));\n    };\n});\ndefine('skylark-asttypes/def/es2018',[\n    './es2017',\n    '../types',\n    '../shared'\n], function (es2017Def, typesPlugin, sharedPlugin) {\n    'use strict';\n    return function (fork) {\n        fork.use(es2017Def);\n        const types = fork.use(typesPlugin);\n        const def = types.Type.def;\n        const or = types.Type.or;\n        const defaults = fork.use(sharedPlugin).defaults;\n        def('ForOfStatement').field('await', Boolean, defaults['false']);\n        def('SpreadProperty').bases('Node').build('argument').field('argument', def('Expression'));\n        def('ObjectExpression').field('properties', [or(def('Property'), def('SpreadProperty'), def('SpreadElement'))]);\n        def('TemplateElement').field('value', {\n            'cooked': or(String, null),\n            'raw': String\n        });\n        def('SpreadPropertyPattern').bases('Pattern').build('argument').field('argument', def('Pattern'));\n        def('ObjectPattern').field('properties', [or(def('PropertyPattern'), def('Property'), def('RestElement'), def('SpreadPropertyPattern'))]);\n    };\n});\ndefine('skylark-asttypes/def/es2019',[\n    './es2018',\n    '../types',\n    '../shared'\n], function (es2018Def, typesPlugin, sharedPlugin) {\n    'use strict';\n    return function (fork) {\n        fork.use(es2018Def);\n        const types = fork.use(typesPlugin);\n        const def = types.Type.def;\n        const or = types.Type.or;\n        const defaults = fork.use(sharedPlugin).defaults;\n        def('CatchClause').field('param', or(def('Pattern'), null), defaults['null']);\n    };\n});\ndefine('skylark-asttypes/def/es2020',[\n    './operators/es2020',\n    './es2019',\n    '../types',\n    '../shared'\n], function (es2020OpsDef, es2019Def, typesPlugin, sharedPlugin) {\n    'use strict';\n    return function (fork) {\n        fork.use(es2020OpsDef);\n        fork.use(es2019Def);\n        const types = fork.use(typesPlugin);\n        const def = types.Type.def;\n        const or = types.Type.or;\n        const shared = fork.use(sharedPlugin);\n        const defaults = shared.defaults;\n        def('ImportExpression').bases('Expression').build('source').field('source', def('Expression'));\n        def('ExportAllDeclaration').bases('Declaration').build('source', 'exported').field('source', def('Literal')).field('exported', or(def('Identifier'), null, void 0), defaults['null']);\n        def('ChainElement').bases('Node').field('optional', Boolean, defaults['false']);\n        def('CallExpression').bases('Expression', 'ChainElement');\n        def('MemberExpression').bases('Expression', 'ChainElement');\n        def('ChainExpression').bases('Expression').build('expression').field('expression', def('ChainElement'));\n        def('OptionalCallExpression').bases('CallExpression').build('callee', 'arguments', 'optional').field('optional', Boolean, defaults['true']);\n        def('OptionalMemberExpression').bases('MemberExpression').build('object', 'property', 'computed', 'optional').field('optional', Boolean, defaults['true']);\n    };\n});\ndefine('skylark-asttypes/def/es2021',[\n    './operators/es2021',\n    './es2020'\n], function (es2021OpsDef, es2020Def) {\n    'use strict';\n    return function (fork) {\n        fork.use(es2021OpsDef);\n        fork.use(es2020Def);\n    };\n});\ndefine('skylark-asttypes/def/es2022',[\n    './es2021',\n    '../types'\n], function (es2021Def, typesPlugin) {\n    'use strict';\n    return function (fork) {\n        fork.use(es2021Def);\n        const types = fork.use(typesPlugin);\n        const def = types.Type.def;\n        def('StaticBlock').bases('Declaration').build('body').field('body', [def('Statement')]);\n    };\n});\ndefine('skylark-asttypes/def/es-proposals',[\n    '../types',\n    './es2022'\n], function (typesPlugin, es2022Def) {\n    'use strict';\n    return function (fork) {\n        fork.use(es2022Def);\n        const types = fork.use(typesPlugin);\n        const Type = types.Type;\n        const def = types.Type.def;\n        const or = Type.or;\n        const shared = fork.use(sharedPlugin);\n        const defaults = shared.defaults;\n        def('AwaitExpression').build('argument', 'all').field('argument', or(def('Expression'), null)).field('all', Boolean, defaults['false']);\n        def('Decorator').bases('Node').build('expression').field('expression', def('Expression'));\n        def('Property').field('decorators', or([def('Decorator')], null), defaults['null']);\n        def('MethodDefinition').field('decorators', or([def('Decorator')], null), defaults['null']);\n        def('PrivateName').bases('Expression', 'Pattern').build('id').field('id', def('Identifier'));\n        def('ClassPrivateProperty').bases('ClassProperty').build('key', 'value').field('key', def('PrivateName')).field('value', or(def('Expression'), null), defaults['null']);\n        def('ImportAttribute').bases('Node').build('key', 'value').field('key', or(def('Identifier'), def('Literal'))).field('value', def('Expression'));\n        [\n            'ImportDeclaration',\n            'ExportAllDeclaration',\n            'ExportNamedDeclaration'\n        ].forEach(decl => {\n            def(decl).field('assertions', [def('ImportAttribute')], defaults.emptyArray);\n        });\n        def('RecordExpression').bases('Expression').build('properties').field('properties', [or(def('ObjectProperty'), def('ObjectMethod'), def('SpreadElement'))]);\n        def('TupleExpression').bases('Expression').build('elements').field('elements', [or(def('Expression'), def('SpreadElement'), null)]);\n        def('ModuleExpression').bases('Node').build('body').field('body', def('Program'));\n    };\n});\ndefine('skylark-asttypes/def/jsx',[\n    './es-proposals',\n    '../types',\n    '../shared'\n], function (esProposalsDef, typesPlugin, sharedPlugin) {\n    'use strict';\n    return function (fork) {\n        fork.use(esProposalsDef);\n        const types = fork.use(typesPlugin);\n        const def = types.Type.def;\n        const or = types.Type.or;\n        const defaults = fork.use(sharedPlugin).defaults;\n        def('JSXAttribute').bases('Node').build('name', 'value').field('name', or(def('JSXIdentifier'), def('JSXNamespacedName'))).field('value', or(def('Literal'), def('JSXExpressionContainer'), def('JSXElement'), def('JSXFragment'), null), defaults['null']);\n        def('JSXIdentifier').bases('Identifier').build('name').field('name', String);\n        def('JSXNamespacedName').bases('Node').build('namespace', 'name').field('namespace', def('JSXIdentifier')).field('name', def('JSXIdentifier'));\n        def('JSXMemberExpression').bases('MemberExpression').build('object', 'property').field('object', or(def('JSXIdentifier'), def('JSXMemberExpression'))).field('property', def('JSXIdentifier')).field('computed', Boolean, defaults.false);\n        const JSXElementName = or(def('JSXIdentifier'), def('JSXNamespacedName'), def('JSXMemberExpression'));\n        def('JSXSpreadAttribute').bases('Node').build('argument').field('argument', def('Expression'));\n        const JSXAttributes = [or(def('JSXAttribute'), def('JSXSpreadAttribute'))];\n        def('JSXExpressionContainer').bases('Expression').build('expression').field('expression', or(def('Expression'), def('JSXEmptyExpression')));\n        const JSXChildren = [or(def('JSXText'), def('JSXExpressionContainer'), def('JSXSpreadChild'), def('JSXElement'), def('JSXFragment'), def('Literal'))];\n        def('JSXElement').bases('Expression').build('openingElement', 'closingElement', 'children').field('openingElement', def('JSXOpeningElement')).field('closingElement', or(def('JSXClosingElement'), null), defaults['null']).field('children', JSXChildren, defaults.emptyArray).field('name', JSXElementName, function () {\n            return this.openingElement.name;\n        }, true).field('selfClosing', Boolean, function () {\n            return this.openingElement.selfClosing;\n        }, true).field('attributes', JSXAttributes, function () {\n            return this.openingElement.attributes;\n        }, true);\n        def('JSXOpeningElement').bases('Node').build('name', 'attributes', 'selfClosing').field('name', JSXElementName).field('attributes', JSXAttributes, defaults.emptyArray).field('selfClosing', Boolean, defaults['false']);\n        def('JSXClosingElement').bases('Node').build('name').field('name', JSXElementName);\n        def('JSXFragment').bases('Expression').build('openingFragment', 'closingFragment', 'children').field('openingFragment', def('JSXOpeningFragment')).field('closingFragment', def('JSXClosingFragment')).field('children', JSXChildren, defaults.emptyArray);\n        def('JSXOpeningFragment').bases('Node').build();\n        def('JSXClosingFragment').bases('Node').build();\n        def('JSXText').bases('Literal').build('value', 'raw').field('value', String).field('raw', String, function () {\n            return this.value;\n        });\n        def('JSXEmptyExpression').bases('Node').build();\n        def('JSXSpreadChild').bases('Node').build('expression').field('expression', def('Expression'));\n    };\n});\ndefine('skylark-asttypes/def/type-annotations',[\n    '../types',\n    '../shared'\n], function (typesPlugin, sharedPlugin) {\n    'use strict';\n    return function (fork) {\n        var types = fork.use(typesPlugin);\n        var def = types.Type.def;\n        var or = types.Type.or;\n        var defaults = fork.use(sharedPlugin).defaults;\n        var TypeAnnotation = or(def('TypeAnnotation'), def('TSTypeAnnotation'), null);\n        var TypeParamDecl = or(def('TypeParameterDeclaration'), def('TSTypeParameterDeclaration'), null);\n        def('Identifier').field('typeAnnotation', TypeAnnotation, defaults['null']);\n        def('ObjectPattern').field('typeAnnotation', TypeAnnotation, defaults['null']);\n        def('Function').field('returnType', TypeAnnotation, defaults['null']).field('typeParameters', TypeParamDecl, defaults['null']);\n        def('ClassProperty').build('key', 'value', 'typeAnnotation', 'static').field('value', or(def('Expression'), null)).field('static', Boolean, defaults['false']).field('typeAnnotation', TypeAnnotation, defaults['null']);\n        [\n            'ClassDeclaration',\n            'ClassExpression'\n        ].forEach(typeName => {\n            def(typeName).field('typeParameters', TypeParamDecl, defaults['null']).field('superTypeParameters', or(def('TypeParameterInstantiation'), def('TSTypeParameterInstantiation'), null), defaults['null']).field('implements', or([def('ClassImplements')], [def('TSExpressionWithTypeArguments')]), defaults.emptyArray);\n        });\n    };\n});\ndefine('skylark-asttypes/def/flow',[\n    './es-proposals',\n    './type-annotations',\n    '../types',\n    '../shared'\n], function (esProposalsDef, typeAnnotationsDef, typesPlugin, sharedPlugin) {\n    'use strict';\n    return function (fork) {\n        fork.use(esProposalsDef);\n        fork.use(typeAnnotationsDef);\n        const types = fork.use(typesPlugin);\n        const def = types.Type.def;\n        const or = types.Type.or;\n        const defaults = fork.use(sharedPlugin).defaults;\n        def('Flow').bases('Node');\n        def('FlowType').bases('Flow');\n        def('AnyTypeAnnotation').bases('FlowType').build();\n        def('EmptyTypeAnnotation').bases('FlowType').build();\n        def('MixedTypeAnnotation').bases('FlowType').build();\n        def('VoidTypeAnnotation').bases('FlowType').build();\n        def('SymbolTypeAnnotation').bases('FlowType').build();\n        def('NumberTypeAnnotation').bases('FlowType').build();\n        def('BigIntTypeAnnotation').bases('FlowType').build();\n        def('NumberLiteralTypeAnnotation').bases('FlowType').build('value', 'raw').field('value', Number).field('raw', String);\n        def('NumericLiteralTypeAnnotation').bases('FlowType').build('value', 'raw').field('value', Number).field('raw', String);\n        def('BigIntLiteralTypeAnnotation').bases('FlowType').build('value', 'raw').field('value', null).field('raw', String);\n        def('StringTypeAnnotation').bases('FlowType').build();\n        def('StringLiteralTypeAnnotation').bases('FlowType').build('value', 'raw').field('value', String).field('raw', String);\n        def('BooleanTypeAnnotation').bases('FlowType').build();\n        def('BooleanLiteralTypeAnnotation').bases('FlowType').build('value', 'raw').field('value', Boolean).field('raw', String);\n        def('TypeAnnotation').bases('Node').build('typeAnnotation').field('typeAnnotation', def('FlowType'));\n        def('NullableTypeAnnotation').bases('FlowType').build('typeAnnotation').field('typeAnnotation', def('FlowType'));\n        def('NullLiteralTypeAnnotation').bases('FlowType').build();\n        def('NullTypeAnnotation').bases('FlowType').build();\n        def('ThisTypeAnnotation').bases('FlowType').build();\n        def('ExistsTypeAnnotation').bases('FlowType').build();\n        def('ExistentialTypeParam').bases('FlowType').build();\n        def('FunctionTypeAnnotation').bases('FlowType').build('params', 'returnType', 'rest', 'typeParameters').field('params', [def('FunctionTypeParam')]).field('returnType', def('FlowType')).field('rest', or(def('FunctionTypeParam'), null)).field('typeParameters', or(def('TypeParameterDeclaration'), null));\n        def('FunctionTypeParam').bases('Node').build('name', 'typeAnnotation', 'optional').field('name', or(def('Identifier'), null)).field('typeAnnotation', def('FlowType')).field('optional', Boolean);\n        def('ArrayTypeAnnotation').bases('FlowType').build('elementType').field('elementType', def('FlowType'));\n        def('ObjectTypeAnnotation').bases('FlowType').build('properties', 'indexers', 'callProperties').field('properties', [or(def('ObjectTypeProperty'), def('ObjectTypeSpreadProperty'))]).field('indexers', [def('ObjectTypeIndexer')], defaults.emptyArray).field('callProperties', [def('ObjectTypeCallProperty')], defaults.emptyArray).field('inexact', or(Boolean, void 0), defaults['undefined']).field('exact', Boolean, defaults['false']).field('internalSlots', [def('ObjectTypeInternalSlot')], defaults.emptyArray);\n        def('Variance').bases('Node').build('kind').field('kind', or('plus', 'minus'));\n        const LegacyVariance = or(def('Variance'), 'plus', 'minus', null);\n        def('ObjectTypeProperty').bases('Node').build('key', 'value', 'optional').field('key', or(def('Literal'), def('Identifier'))).field('value', def('FlowType')).field('optional', Boolean).field('variance', LegacyVariance, defaults['null']);\n        def('ObjectTypeIndexer').bases('Node').build('id', 'key', 'value').field('id', def('Identifier')).field('key', def('FlowType')).field('value', def('FlowType')).field('variance', LegacyVariance, defaults['null']).field('static', Boolean, defaults['false']);\n        def('ObjectTypeCallProperty').bases('Node').build('value').field('value', def('FunctionTypeAnnotation')).field('static', Boolean, defaults['false']);\n        def('QualifiedTypeIdentifier').bases('Node').build('qualification', 'id').field('qualification', or(def('Identifier'), def('QualifiedTypeIdentifier'))).field('id', def('Identifier'));\n        def('GenericTypeAnnotation').bases('FlowType').build('id', 'typeParameters').field('id', or(def('Identifier'), def('QualifiedTypeIdentifier'))).field('typeParameters', or(def('TypeParameterInstantiation'), null));\n        def('MemberTypeAnnotation').bases('FlowType').build('object', 'property').field('object', def('Identifier')).field('property', or(def('MemberTypeAnnotation'), def('GenericTypeAnnotation')));\n        def('IndexedAccessType').bases('FlowType').build('objectType', 'indexType').field('objectType', def('FlowType')).field('indexType', def('FlowType'));\n        def('OptionalIndexedAccessType').bases('FlowType').build('objectType', 'indexType', 'optional').field('objectType', def('FlowType')).field('indexType', def('FlowType')).field('optional', Boolean);\n        def('UnionTypeAnnotation').bases('FlowType').build('types').field('types', [def('FlowType')]);\n        def('IntersectionTypeAnnotation').bases('FlowType').build('types').field('types', [def('FlowType')]);\n        def('TypeofTypeAnnotation').bases('FlowType').build('argument').field('argument', def('FlowType'));\n        def('ObjectTypeSpreadProperty').bases('Node').build('argument').field('argument', def('FlowType'));\n        def('ObjectTypeInternalSlot').bases('Node').build('id', 'value', 'optional', 'static', 'method').field('id', def('Identifier')).field('value', def('FlowType')).field('optional', Boolean).field('static', Boolean).field('method', Boolean);\n        def('TypeParameterDeclaration').bases('Node').build('params').field('params', [def('TypeParameter')]);\n        def('TypeParameterInstantiation').bases('Node').build('params').field('params', [def('FlowType')]);\n        def('TypeParameter').bases('FlowType').build('name', 'variance', 'bound', 'default').field('name', String).field('variance', LegacyVariance, defaults['null']).field('bound', or(def('TypeAnnotation'), null), defaults['null']).field('default', or(def('FlowType'), null), defaults['null']);\n        def('ClassProperty').field('variance', LegacyVariance, defaults['null']);\n        def('ClassImplements').bases('Node').build('id').field('id', def('Identifier')).field('superClass', or(def('Expression'), null), defaults['null']).field('typeParameters', or(def('TypeParameterInstantiation'), null), defaults['null']);\n        def('InterfaceTypeAnnotation').bases('FlowType').build('body', 'extends').field('body', def('ObjectTypeAnnotation')).field('extends', or([def('InterfaceExtends')], null), defaults['null']);\n        def('InterfaceDeclaration').bases('Declaration').build('id', 'body', 'extends').field('id', def('Identifier')).field('typeParameters', or(def('TypeParameterDeclaration'), null), defaults['null']).field('body', def('ObjectTypeAnnotation')).field('extends', [def('InterfaceExtends')]);\n        def('DeclareInterface').bases('InterfaceDeclaration').build('id', 'body', 'extends');\n        def('InterfaceExtends').bases('Node').build('id').field('id', def('Identifier')).field('typeParameters', or(def('TypeParameterInstantiation'), null), defaults['null']);\n        def('TypeAlias').bases('Declaration').build('id', 'typeParameters', 'right').field('id', def('Identifier')).field('typeParameters', or(def('TypeParameterDeclaration'), null)).field('right', def('FlowType'));\n        def('DeclareTypeAlias').bases('TypeAlias').build('id', 'typeParameters', 'right');\n        def('OpaqueType').bases('Declaration').build('id', 'typeParameters', 'impltype', 'supertype').field('id', def('Identifier')).field('typeParameters', or(def('TypeParameterDeclaration'), null)).field('impltype', def('FlowType')).field('supertype', or(def('FlowType'), null));\n        def('DeclareOpaqueType').bases('OpaqueType').build('id', 'typeParameters', 'supertype').field('impltype', or(def('FlowType'), null));\n        def('TypeCastExpression').bases('Expression').build('expression', 'typeAnnotation').field('expression', def('Expression')).field('typeAnnotation', def('TypeAnnotation'));\n        def('TupleTypeAnnotation').bases('FlowType').build('types').field('types', [def('FlowType')]);\n        def('DeclareVariable').bases('Statement').build('id').field('id', def('Identifier'));\n        def('DeclareFunction').bases('Statement').build('id').field('id', def('Identifier')).field('predicate', or(def('FlowPredicate'), null), defaults['null']);\n        def('DeclareClass').bases('InterfaceDeclaration').build('id');\n        def('DeclareModule').bases('Statement').build('id', 'body').field('id', or(def('Identifier'), def('Literal'))).field('body', def('BlockStatement'));\n        def('DeclareModuleExports').bases('Statement').build('typeAnnotation').field('typeAnnotation', def('TypeAnnotation'));\n        def('DeclareExportDeclaration').bases('Declaration').build('default', 'declaration', 'specifiers', 'source').field('default', Boolean).field('declaration', or(def('DeclareVariable'), def('DeclareFunction'), def('DeclareClass'), def('FlowType'), def('TypeAlias'), def('DeclareOpaqueType'), def('InterfaceDeclaration'), null)).field('specifiers', [or(def('ExportSpecifier'), def('ExportBatchSpecifier'))], defaults.emptyArray).field('source', or(def('Literal'), null), defaults['null']);\n        def('DeclareExportAllDeclaration').bases('Declaration').build('source').field('source', or(def('Literal'), null), defaults['null']);\n        def('ImportDeclaration').field('importKind', or('value', 'type', 'typeof'), () => 'value');\n        def('FlowPredicate').bases('Flow');\n        def('InferredPredicate').bases('FlowPredicate').build();\n        def('DeclaredPredicate').bases('FlowPredicate').build('value').field('value', def('Expression'));\n        def('Function').field('predicate', or(def('FlowPredicate'), null), defaults['null']);\n        def('CallExpression').field('typeArguments', or(null, def('TypeParameterInstantiation')), defaults['null']);\n        def('NewExpression').field('typeArguments', or(null, def('TypeParameterInstantiation')), defaults['null']);\n        def('EnumDeclaration').bases('Declaration').build('id', 'body').field('id', def('Identifier')).field('body', or(def('EnumBooleanBody'), def('EnumNumberBody'), def('EnumStringBody'), def('EnumSymbolBody')));\n        def('EnumBooleanBody').build('members', 'explicitType').field('members', [def('EnumBooleanMember')]).field('explicitType', Boolean);\n        def('EnumNumberBody').build('members', 'explicitType').field('members', [def('EnumNumberMember')]).field('explicitType', Boolean);\n        def('EnumStringBody').build('members', 'explicitType').field('members', or([def('EnumStringMember')], [def('EnumDefaultedMember')])).field('explicitType', Boolean);\n        def('EnumSymbolBody').build('members').field('members', [def('EnumDefaultedMember')]);\n        def('EnumBooleanMember').build('id', 'init').field('id', def('Identifier')).field('init', or(def('Literal'), Boolean));\n        def('EnumNumberMember').build('id', 'init').field('id', def('Identifier')).field('init', def('Literal'));\n        def('EnumStringMember').build('id', 'init').field('id', def('Identifier')).field('init', def('Literal'));\n        def('EnumDefaultedMember').build('id').field('id', def('Identifier'));\n    };\n});\ndefine('skylark-asttypes/def/esprima',[\n    './es-proposals',\n    '../types',\n    '../shared'\n], function (esProposalsDef, typesPlugin, sharedPlugin) {\n    'use strict';\n    return function (fork) {\n        fork.use(esProposalsDef);\n        var types = fork.use(typesPlugin);\n        var defaults = fork.use(sharedPlugin).defaults;\n        var def = types.Type.def;\n        var or = types.Type.or;\n        def('VariableDeclaration').field('declarations', [or(def('VariableDeclarator'), def('Identifier'))]);\n        def('Property').field('value', or(def('Expression'), def('Pattern')));\n        def('ArrayPattern').field('elements', [or(def('Pattern'), def('SpreadElement'), null)]);\n        def('ObjectPattern').field('properties', [or(def('Property'), def('PropertyPattern'), def('SpreadPropertyPattern'), def('SpreadProperty'))]);\n        def('ExportSpecifier').bases('ModuleSpecifier').build('id', 'name');\n        def('ExportBatchSpecifier').bases('Specifier').build();\n        def('ExportDeclaration').bases('Declaration').build('default', 'declaration', 'specifiers', 'source').field('default', Boolean).field('declaration', or(def('Declaration'), def('Expression'), null)).field('specifiers', [or(def('ExportSpecifier'), def('ExportBatchSpecifier'))], defaults.emptyArray).field('source', or(def('Literal'), null), defaults['null']);\n        def('Block').bases('Comment').build('value', 'leading', 'trailing');\n        def('Line').bases('Comment').build('value', 'leading', 'trailing');\n    };\n});\ndefine('skylark-asttypes/def/babel-core',[\n    './es-proposals',\n    '../types'\n], function (esProposalsDef, typesPlugin) {\n    'use strict';\n    return function (fork) {\n        fork.use(esProposalsDef);\n        const types = fork.use(typesPlugin);\n        const defaults = fork.use(sharedPlugin).defaults;\n        const def = types.Type.def;\n        const or = types.Type.or;\n        const {undefined: isUndefined} = types.builtInTypes;\n        def('Noop').bases('Statement').build();\n        def('DoExpression').bases('Expression').build('body').field('body', [def('Statement')]);\n        def('BindExpression').bases('Expression').build('object', 'callee').field('object', or(def('Expression'), null)).field('callee', def('Expression'));\n        def('ParenthesizedExpression').bases('Expression').build('expression').field('expression', def('Expression'));\n        def('ExportNamespaceSpecifier').bases('Specifier').build('exported').field('exported', def('Identifier'));\n        def('ExportDefaultSpecifier').bases('Specifier').build('exported').field('exported', def('Identifier'));\n        def('CommentBlock').bases('Comment').build('value', 'leading', 'trailing');\n        def('CommentLine').bases('Comment').build('value', 'leading', 'trailing');\n        def('Directive').bases('Node').build('value').field('value', def('DirectiveLiteral'));\n        def('DirectiveLiteral').bases('Node', 'Expression').build('value').field('value', String, defaults['use strict']);\n        def('InterpreterDirective').bases('Node').build('value').field('value', String);\n        def('BlockStatement').bases('Statement').build('body').field('body', [def('Statement')]).field('directives', [def('Directive')], defaults.emptyArray);\n        def('Program').bases('Node').build('body').field('body', [def('Statement')]).field('directives', [def('Directive')], defaults.emptyArray).field('interpreter', or(def('InterpreterDirective'), null), defaults['null']);\n        function makeLiteralExtra(rawValueType = String, toRaw) {\n            return [\n                'extra',\n                {\n                    rawValue: rawValueType,\n                    raw: String\n                },\n                function getDefault() {\n                    const value = types.getFieldValue(this, 'value');\n                    return {\n                        rawValue: value,\n                        raw: toRaw ? toRaw(value) : String(value)\n                    };\n                }\n            ];\n        }\n        def('StringLiteral').bases('Literal').build('value').field('value', String).field(...makeLiteralExtra(String, val => JSON.stringify(val)));\n        def('NumericLiteral').bases('Literal').build('value').field('value', Number).field('raw', or(String, null), defaults['null']).field(...makeLiteralExtra(Number));\n        def('BigIntLiteral').bases('Literal').build('value').field('value', or(String, Number)).field(...makeLiteralExtra(String, val => val + 'n'));\n        def('DecimalLiteral').bases('Literal').build('value').field('value', String).field(...makeLiteralExtra(String, val => val + 'm'));\n        def('NullLiteral').bases('Literal').build().field('value', null, defaults['null']);\n        def('BooleanLiteral').bases('Literal').build('value').field('value', Boolean);\n        def('RegExpLiteral').bases('Literal').build('pattern', 'flags').field('pattern', String).field('flags', String).field('value', RegExp, function () {\n            return new RegExp(this.pattern, this.flags);\n        }).field(...makeLiteralExtra(or(RegExp, isUndefined), exp => `/${ exp.pattern }/${ exp.flags || '' }`)).field('regex', {\n            pattern: String,\n            flags: String\n        }, function () {\n            return {\n                pattern: this.pattern,\n                flags: this.flags\n            };\n        });\n        var ObjectExpressionProperty = or(def('Property'), def('ObjectMethod'), def('ObjectProperty'), def('SpreadProperty'), def('SpreadElement'));\n        def('ObjectExpression').bases('Expression').build('properties').field('properties', [ObjectExpressionProperty]);\n        def('ObjectMethod').bases('Node', 'Function').build('kind', 'key', 'params', 'body', 'computed').field('kind', or('method', 'get', 'set')).field('key', or(def('Literal'), def('Identifier'), def('Expression'))).field('params', [def('Pattern')]).field('body', def('BlockStatement')).field('computed', Boolean, defaults['false']).field('generator', Boolean, defaults['false']).field('async', Boolean, defaults['false']).field('accessibility', or(def('Literal'), null), defaults['null']).field('decorators', or([def('Decorator')], null), defaults['null']);\n        def('ObjectProperty').bases('Node').build('key', 'value').field('key', or(def('Literal'), def('Identifier'), def('Expression'))).field('value', or(def('Expression'), def('Pattern'))).field('accessibility', or(def('Literal'), null), defaults['null']).field('computed', Boolean, defaults['false']);\n        var ClassBodyElement = or(def('MethodDefinition'), def('VariableDeclarator'), def('ClassPropertyDefinition'), def('ClassProperty'), def('ClassPrivateProperty'), def('ClassMethod'), def('ClassPrivateMethod'), def('ClassAccessorProperty'), def('StaticBlock'));\n        def('ClassBody').bases('Declaration').build('body').field('body', [ClassBodyElement]);\n        def('ClassMethod').bases('Declaration', 'Function').build('kind', 'key', 'params', 'body', 'computed', 'static').field('key', or(def('Literal'), def('Identifier'), def('Expression')));\n        def('ClassPrivateMethod').bases('Declaration', 'Function').build('key', 'params', 'body', 'kind', 'computed', 'static').field('key', def('PrivateName'));\n        def('ClassAccessorProperty').bases('Declaration').build('key', 'value', 'decorators', 'computed', 'static').field('key', or(def('Literal'), def('Identifier'), def('PrivateName'), def('Expression'))).field('value', or(def('Expression'), null), defaults['null']);\n        [\n            'ClassMethod',\n            'ClassPrivateMethod'\n        ].forEach(typeName => {\n            def(typeName).field('kind', or('get', 'set', 'method', 'constructor'), () => 'method').field('body', def('BlockStatement')).field('access', or('public', 'private', 'protected', null), defaults['null']);\n        });\n        [\n            'ClassMethod',\n            'ClassPrivateMethod',\n            'ClassAccessorProperty'\n        ].forEach(typeName => {\n            def(typeName).field('computed', Boolean, defaults['false']).field('static', Boolean, defaults['false']).field('abstract', Boolean, defaults['false']).field('accessibility', or('public', 'private', 'protected', null), defaults['null']).field('decorators', or([def('Decorator')], null), defaults['null']).field('definite', Boolean, defaults['false']).field('optional', Boolean, defaults['false']).field('override', Boolean, defaults['false']).field('readonly', Boolean, defaults['false']);\n        });\n        var ObjectPatternProperty = or(def('Property'), def('PropertyPattern'), def('SpreadPropertyPattern'), def('SpreadProperty'), def('ObjectProperty'), def('RestProperty'), def('RestElement'));\n        def('ObjectPattern').bases('Pattern').build('properties').field('properties', [ObjectPatternProperty]).field('decorators', or([def('Decorator')], null), defaults['null']);\n        def('SpreadProperty').bases('Node').build('argument').field('argument', def('Expression'));\n        def('RestProperty').bases('Node').build('argument').field('argument', def('Expression'));\n        def('ForAwaitStatement').bases('Statement').build('left', 'right', 'body').field('left', or(def('VariableDeclaration'), def('Expression'))).field('right', def('Expression')).field('body', def('Statement'));\n        def('Import').bases('Expression').build();\n    };\n    ;\n});\ndefine('skylark-asttypes/def/babel',[\n    '../types',\n    './babel-core',\n    './flow'\n], function (typesPlugin, babelCoreDef, flowDef) {\n    'use strict';\n    return function (fork) {\n        const types = fork.use(typesPlugin);\n        const def = types.Type.def;\n        fork.use(babelCoreDef);\n        fork.use(flowDef);\n        def('V8IntrinsicIdentifier').bases('Expression').build('name').field('name', String);\n        def('TopicReference').bases('Expression').build();\n    };\n});\ndefine('skylark-asttypes/def/typescript',[\n    './babel-core',\n    './type-annotations',\n    '../types',\n    '../shared'\n], function (babelCoreDef, typeAnnotationsDef, typesPlugin, sharedPlugin) {\n    'use strict';\n    return function (fork) {\n        fork.use(babelCoreDef);\n        fork.use(typeAnnotationsDef);\n        var types = fork.use(typesPlugin);\n        var n = types.namedTypes;\n        var def = types.Type.def;\n        var or = types.Type.or;\n        var defaults = fork.use(sharedPlugin).defaults;\n        var StringLiteral = types.Type.from(function (value, deep) {\n            if (n.StringLiteral && n.StringLiteral.check(value, deep)) {\n                return true;\n            }\n            if (n.Literal && n.Literal.check(value, deep) && typeof value.value === 'string') {\n                return true;\n            }\n            return false;\n        }, 'StringLiteral');\n        def('TSType').bases('Node');\n        var TSEntityName = or(def('Identifier'), def('TSQualifiedName'));\n        def('TSTypeReference').bases('TSType', 'TSHasOptionalTypeParameterInstantiation').build('typeName', 'typeParameters').field('typeName', TSEntityName);\n        def('TSHasOptionalTypeParameterInstantiation').field('typeParameters', or(def('TSTypeParameterInstantiation'), null), defaults['null']);\n        def('TSHasOptionalTypeParameters').field('typeParameters', or(def('TSTypeParameterDeclaration'), null, void 0), defaults['null']);\n        def('TSHasOptionalTypeAnnotation').field('typeAnnotation', or(def('TSTypeAnnotation'), null), defaults['null']);\n        def('TSQualifiedName').bases('Node').build('left', 'right').field('left', TSEntityName).field('right', TSEntityName);\n        def('TSAsExpression').bases('Expression', 'Pattern').build('expression', 'typeAnnotation').field('expression', def('Expression')).field('typeAnnotation', def('TSType')).field('extra', or({ parenthesized: Boolean }, null), defaults['null']);\n        def('TSTypeCastExpression').bases('Expression').build('expression', 'typeAnnotation').field('expression', def('Expression')).field('typeAnnotation', def('TSType'));\n        def('TSSatisfiesExpression').bases('Expression', 'Pattern').build('expression', 'typeAnnotation').field('expression', def('Expression')).field('typeAnnotation', def('TSType'));\n        def('TSNonNullExpression').bases('Expression', 'Pattern').build('expression').field('expression', def('Expression'));\n        [\n            'TSAnyKeyword',\n            'TSBigIntKeyword',\n            'TSBooleanKeyword',\n            'TSNeverKeyword',\n            'TSNullKeyword',\n            'TSNumberKeyword',\n            'TSObjectKeyword',\n            'TSStringKeyword',\n            'TSSymbolKeyword',\n            'TSUndefinedKeyword',\n            'TSUnknownKeyword',\n            'TSVoidKeyword',\n            'TSIntrinsicKeyword',\n            'TSThisType'\n        ].forEach(keywordType => {\n            def(keywordType).bases('TSType').build();\n        });\n        def('TSArrayType').bases('TSType').build('elementType').field('elementType', def('TSType'));\n        def('TSLiteralType').bases('TSType').build('literal').field('literal', or(def('NumericLiteral'), def('StringLiteral'), def('BooleanLiteral'), def('TemplateLiteral'), def('UnaryExpression'), def('BigIntLiteral')));\n        def('TemplateLiteral').field('expressions', or([def('Expression')], [def('TSType')]));\n        [\n            'TSUnionType',\n            'TSIntersectionType'\n        ].forEach(typeName => {\n            def(typeName).bases('TSType').build('types').field('types', [def('TSType')]);\n        });\n        def('TSConditionalType').bases('TSType').build('checkType', 'extendsType', 'trueType', 'falseType').field('checkType', def('TSType')).field('extendsType', def('TSType')).field('trueType', def('TSType')).field('falseType', def('TSType'));\n        def('TSInferType').bases('TSType').build('typeParameter').field('typeParameter', def('TSTypeParameter'));\n        def('TSParenthesizedType').bases('TSType').build('typeAnnotation').field('typeAnnotation', def('TSType'));\n        var ParametersType = [or(def('Identifier'), def('RestElement'), def('ArrayPattern'), def('ObjectPattern'))];\n        [\n            'TSFunctionType',\n            'TSConstructorType'\n        ].forEach(typeName => {\n            def(typeName).bases('TSType', 'TSHasOptionalTypeParameters', 'TSHasOptionalTypeAnnotation').build('parameters').field('parameters', ParametersType);\n        });\n        def('TSDeclareFunction').bases('Declaration', 'TSHasOptionalTypeParameters').build('id', 'params', 'returnType').field('declare', Boolean, defaults['false']).field('async', Boolean, defaults['false']).field('generator', Boolean, defaults['false']).field('id', or(def('Identifier'), null), defaults['null']).field('params', [def('Pattern')]).field('returnType', or(def('TSTypeAnnotation'), def('Noop'), null), defaults['null']);\n        def('TSDeclareMethod').bases('Declaration', 'TSHasOptionalTypeParameters').build('key', 'params', 'returnType').field('async', Boolean, defaults['false']).field('generator', Boolean, defaults['false']).field('params', [def('Pattern')]).field('abstract', Boolean, defaults['false']).field('accessibility', or('public', 'private', 'protected', void 0), defaults['undefined']).field('static', Boolean, defaults['false']).field('computed', Boolean, defaults['false']).field('optional', Boolean, defaults['false']).field('key', or(def('Identifier'), def('StringLiteral'), def('NumericLiteral'), def('Expression'))).field('kind', or('get', 'set', 'method', 'constructor'), function getDefault() {\n            return 'method';\n        }).field('access', or('public', 'private', 'protected', void 0), defaults['undefined']).field('decorators', or([def('Decorator')], null), defaults['null']).field('returnType', or(def('TSTypeAnnotation'), def('Noop'), null), defaults['null']);\n        def('TSMappedType').bases('TSType').build('typeParameter', 'typeAnnotation').field('readonly', or(Boolean, '+', '-'), defaults['false']).field('typeParameter', def('TSTypeParameter')).field('optional', or(Boolean, '+', '-'), defaults['false']).field('typeAnnotation', or(def('TSType'), null), defaults['null']);\n        def('TSTupleType').bases('TSType').build('elementTypes').field('elementTypes', [or(def('TSType'), def('TSNamedTupleMember'))]);\n        def('TSNamedTupleMember').bases('TSType').build('label', 'elementType', 'optional').field('label', def('Identifier')).field('optional', Boolean, defaults['false']).field('elementType', def('TSType'));\n        def('TSRestType').bases('TSType').build('typeAnnotation').field('typeAnnotation', def('TSType'));\n        def('TSOptionalType').bases('TSType').build('typeAnnotation').field('typeAnnotation', def('TSType'));\n        def('TSIndexedAccessType').bases('TSType').build('objectType', 'indexType').field('objectType', def('TSType')).field('indexType', def('TSType'));\n        def('TSTypeOperator').bases('TSType').build('operator').field('operator', String).field('typeAnnotation', def('TSType'));\n        def('TSTypeAnnotation').bases('Node').build('typeAnnotation').field('typeAnnotation', or(def('TSType'), def('TSTypeAnnotation')));\n        def('TSIndexSignature').bases('Declaration', 'TSHasOptionalTypeAnnotation').build('parameters', 'typeAnnotation').field('parameters', [def('Identifier')]).field('readonly', Boolean, defaults['false']);\n        def('TSPropertySignature').bases('Declaration', 'TSHasOptionalTypeAnnotation').build('key', 'typeAnnotation', 'optional').field('key', def('Expression')).field('computed', Boolean, defaults['false']).field('readonly', Boolean, defaults['false']).field('optional', Boolean, defaults['false']).field('initializer', or(def('Expression'), null), defaults['null']);\n        def('TSMethodSignature').bases('Declaration', 'TSHasOptionalTypeParameters', 'TSHasOptionalTypeAnnotation').build('key', 'parameters', 'typeAnnotation').field('key', def('Expression')).field('computed', Boolean, defaults['false']).field('optional', Boolean, defaults['false']).field('parameters', ParametersType);\n        def('TSTypePredicate').bases('TSTypeAnnotation', 'TSType').build('parameterName', 'typeAnnotation', 'asserts').field('parameterName', or(def('Identifier'), def('TSThisType'))).field('typeAnnotation', or(def('TSTypeAnnotation'), null), defaults['null']).field('asserts', Boolean, defaults['false']);\n        [\n            'TSCallSignatureDeclaration',\n            'TSConstructSignatureDeclaration'\n        ].forEach(typeName => {\n            def(typeName).bases('Declaration', 'TSHasOptionalTypeParameters', 'TSHasOptionalTypeAnnotation').build('parameters', 'typeAnnotation').field('parameters', ParametersType);\n        });\n        def('TSEnumMember').bases('Node').build('id', 'initializer').field('id', or(def('Identifier'), StringLiteral)).field('initializer', or(def('Expression'), null), defaults['null']);\n        def('TSTypeQuery').bases('TSType').build('exprName').field('exprName', or(TSEntityName, def('TSImportType')));\n        var TSTypeMember = or(def('TSCallSignatureDeclaration'), def('TSConstructSignatureDeclaration'), def('TSIndexSignature'), def('TSMethodSignature'), def('TSPropertySignature'));\n        def('TSTypeLiteral').bases('TSType').build('members').field('members', [TSTypeMember]);\n        def('TSTypeParameter').bases('Identifier').build('name', 'constraint', 'default').field('name', or(def('Identifier'), String)).field('constraint', or(def('TSType'), void 0), defaults['undefined']).field('default', or(def('TSType'), void 0), defaults['undefined']);\n        def('TSTypeAssertion').bases('Expression', 'Pattern').build('typeAnnotation', 'expression').field('typeAnnotation', def('TSType')).field('expression', def('Expression')).field('extra', or({ parenthesized: Boolean }, null), defaults['null']);\n        def('TSTypeParameterDeclaration').bases('Declaration').build('params').field('params', [def('TSTypeParameter')]);\n        def('TSInstantiationExpression').bases('Expression', 'TSHasOptionalTypeParameterInstantiation').build('expression', 'typeParameters').field('expression', def('Expression'));\n        def('TSTypeParameterInstantiation').bases('Node').build('params').field('params', [def('TSType')]);\n        def('TSEnumDeclaration').bases('Declaration').build('id', 'members').field('id', def('Identifier')).field('const', Boolean, defaults['false']).field('declare', Boolean, defaults['false']).field('members', [def('TSEnumMember')]).field('initializer', or(def('Expression'), null), defaults['null']);\n        def('TSTypeAliasDeclaration').bases('Declaration', 'TSHasOptionalTypeParameters').build('id', 'typeAnnotation').field('id', def('Identifier')).field('declare', Boolean, defaults['false']).field('typeAnnotation', def('TSType'));\n        def('TSModuleBlock').bases('Node').build('body').field('body', [def('Statement')]);\n        def('TSModuleDeclaration').bases('Declaration').build('id', 'body').field('id', or(StringLiteral, TSEntityName)).field('declare', Boolean, defaults['false']).field('global', Boolean, defaults['false']).field('body', or(def('TSModuleBlock'), def('TSModuleDeclaration'), null), defaults['null']);\n        def('TSImportType').bases('TSType', 'TSHasOptionalTypeParameterInstantiation').build('argument', 'qualifier', 'typeParameters').field('argument', StringLiteral).field('qualifier', or(TSEntityName, void 0), defaults['undefined']);\n        def('TSImportEqualsDeclaration').bases('Declaration').build('id', 'moduleReference').field('id', def('Identifier')).field('isExport', Boolean, defaults['false']).field('moduleReference', or(TSEntityName, def('TSExternalModuleReference')));\n        def('TSExternalModuleReference').bases('Declaration').build('expression').field('expression', StringLiteral);\n        def('TSExportAssignment').bases('Statement').build('expression').field('expression', def('Expression'));\n        def('TSNamespaceExportDeclaration').bases('Declaration').build('id').field('id', def('Identifier'));\n        def('TSInterfaceBody').bases('Node').build('body').field('body', [TSTypeMember]);\n        def('TSExpressionWithTypeArguments').bases('TSType', 'TSHasOptionalTypeParameterInstantiation').build('expression', 'typeParameters').field('expression', TSEntityName);\n        def('TSInterfaceDeclaration').bases('Declaration', 'TSHasOptionalTypeParameters').build('id', 'body').field('id', TSEntityName).field('declare', Boolean, defaults['false']).field('extends', or([def('TSExpressionWithTypeArguments')], null), defaults['null']).field('body', def('TSInterfaceBody'));\n        def('TSParameterProperty').bases('Pattern').build('parameter').field('accessibility', or('public', 'private', 'protected', void 0), defaults['undefined']).field('readonly', Boolean, defaults['false']).field('parameter', or(def('Identifier'), def('AssignmentPattern')));\n        def('ClassProperty').field('access', or('public', 'private', 'protected', void 0), defaults['undefined']);\n        def('ClassAccessorProperty').bases('Declaration', 'TSHasOptionalTypeAnnotation');\n        def('ClassBody').field('body', [or(def('MethodDefinition'), def('VariableDeclarator'), def('ClassPropertyDefinition'), def('ClassProperty'), def('ClassPrivateProperty'), def('ClassAccessorProperty'), def('ClassMethod'), def('ClassPrivateMethod'), def('StaticBlock'), def('TSDeclareMethod'), TSTypeMember)]);\n    };\n    ;\n});\ndefine('skylark-asttypes/gen/namedTypes',[],function () {\n    'use strict';\n    return {};\n});\ndefine('skylark-asttypes/gen/visitor',[],function () {\n    'use strict';\n    return {};\n});\ndefine('skylark-asttypes/main',[\n    './fork',\n    './def/es-proposals',\n    './def/jsx',\n    './def/flow',\n    './def/esprima',\n    './def/babel',\n    './def/typescript',\n    './types',\n    './gen/namedTypes',\n    './gen/visitor'\n], function (fork, esProposalsDef, jsxDef, flowDef, esprimaDef, babelDef, typescriptDef, m_types, m_namedTypes, m_visitor) {\n    'use strict';\n    const {ASTNode, AnyType, Field} = m_types;\n    const {namedTypes} = m_namedTypes;\n    const {Visitor} = m_visitor;\n    const {\n        astNodesAreEquivalent,\n        builders,\n        builtInTypes,\n        defineMethod,\n        eachField,\n        finalize,\n        getBuilderName,\n        getFieldNames,\n        getFieldValue,\n        getSupertypeNames,\n        namedTypes: n,\n        NodePath,\n        Path,\n        PathVisitor,\n        someField,\n        Type,\n        use,\n        visit\n    } = fork([\n        esProposalsDef,\n        jsxDef,\n        flowDef,\n        esprimaDef,\n        babelDef,\n        typescriptDef\n    ]);\n    Object.assign(namedTypes, n);\n    return {\n        AnyType,\n        ASTNode,\n        astNodesAreEquivalent,\n        builders,\n        builtInTypes,\n        defineMethod,\n        eachField,\n        Field,\n        finalize,\n        getBuilderName,\n        getFieldNames,\n        getFieldValue,\n        getSupertypeNames,\n        namedTypes,\n        NodePath,\n        Path,\n        PathVisitor,\n        someField,\n        Type,\n        use,\n        visit,\n        Visitor\n    };\n});\ndefine('skylark-asttypes', ['skylark-asttypes/main'], function (main) { return main; });\n\n"]}