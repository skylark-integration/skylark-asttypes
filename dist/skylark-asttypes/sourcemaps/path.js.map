{"version":3,"sources":["path.js"],"names":["define","typesPlugin","hasOwn","Object","prototype","hasOwnProperty","fork","types","use","isArray","builtInTypes","array","isNumber","number","Path","value","parentPath","name","this","Error","__childCache","Pp","getChildCache","path","create","emptyMoves","getMoves","offset","start","end","assert","length","argc","arguments","moves","Math","max","min","cache","i","call","childPath","get","newIndex","getValueProperty","names","actualChildValue","count","constructor","each","callback","context","childPaths","len","map","result","push","filter","shift","move","unshift","args","apply","pop","insertAt","index","insertBefore","pp","insertAtArgs","insertAfter","replace","replacement","results","parentValue","parentCache","check","indexOf","originalLength","spliceArgs","splice"],"mappings":"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","file":"../path.js","sourcesContent":["define(['./types'], function (typesPlugin) {\n    'use strict';\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    return function pathPlugin(fork) {\n        var types = fork.use(typesPlugin);\n        var isArray = types.builtInTypes.array;\n        var isNumber = types.builtInTypes.number;\n        const Path = function Path(value, parentPath, name) {\n            if (!(this instanceof Path)) {\n                throw new Error(\"Path constructor cannot be invoked without 'new'\");\n            }\n            if (parentPath) {\n                if (!(parentPath instanceof Path)) {\n                    throw new Error('');\n                }\n            } else {\n                parentPath = null;\n                name = null;\n            }\n            this.value = value;\n            this.parentPath = parentPath;\n            this.name = name;\n            this.__childCache = null;\n        };\n        var Pp = Path.prototype;\n        function getChildCache(path) {\n            return path.__childCache || (path.__childCache = Object.create(null));\n        }\n        function getChildPath(path, name) {\n            var cache = getChildCache(path);\n            var actualChildValue = path.getValueProperty(name);\n            var childPath = cache[name];\n            if (!hasOwn.call(cache, name) || childPath.value !== actualChildValue) {\n                childPath = cache[name] = new path.constructor(actualChildValue, path, name);\n            }\n            return childPath;\n        }\n        Pp.getValueProperty = function getValueProperty(name) {\n            return this.value[name];\n        };\n        Pp.get = function get(...names) {\n            var path = this;\n            var count = names.length;\n            for (var i = 0; i < count; ++i) {\n                path = getChildPath(path, names[i]);\n            }\n            return path;\n        };\n        Pp.each = function each(callback, context) {\n            var childPaths = [];\n            var len = this.value.length;\n            var i = 0;\n            for (var i = 0; i < len; ++i) {\n                if (hasOwn.call(this.value, i)) {\n                    childPaths[i] = this.get(i);\n                }\n            }\n            context = context || this;\n            for (i = 0; i < len; ++i) {\n                if (hasOwn.call(childPaths, i)) {\n                    callback.call(context, childPaths[i]);\n                }\n            }\n        };\n        Pp.map = function map(callback, context) {\n            var result = [];\n            this.each(function (childPath) {\n                result.push(callback.call(this, childPath));\n            }, context);\n            return result;\n        };\n        Pp.filter = function filter(callback, context) {\n            var result = [];\n            this.each(function (childPath) {\n                if (callback.call(this, childPath)) {\n                    result.push(childPath);\n                }\n            }, context);\n            return result;\n        };\n        function emptyMoves() {\n        }\n        function getMoves(path, offset, start, end) {\n            isArray.assert(path.value);\n            if (offset === 0) {\n                return emptyMoves;\n            }\n            var length = path.value.length;\n            if (length < 1) {\n                return emptyMoves;\n            }\n            var argc = arguments.length;\n            if (argc === 2) {\n                start = 0;\n                end = length;\n            } else if (argc === 3) {\n                start = Math.max(start, 0);\n                end = length;\n            } else {\n                start = Math.max(start, 0);\n                end = Math.min(end, length);\n            }\n            isNumber.assert(start);\n            isNumber.assert(end);\n            var moves = Object.create(null);\n            var cache = getChildCache(path);\n            for (var i = start; i < end; ++i) {\n                if (hasOwn.call(path.value, i)) {\n                    var childPath = path.get(i);\n                    if (childPath.name !== i) {\n                        throw new Error('');\n                    }\n                    var newIndex = i + offset;\n                    childPath.name = newIndex;\n                    moves[newIndex] = childPath;\n                    delete cache[i];\n                }\n            }\n            delete cache.length;\n            return function () {\n                for (var newIndex in moves) {\n                    var childPath = moves[newIndex];\n                    if (childPath.name !== +newIndex) {\n                        throw new Error('');\n                    }\n                    cache[newIndex] = childPath;\n                    path.value[newIndex] = childPath.value;\n                }\n            };\n        }\n        Pp.shift = function shift() {\n            var move = getMoves(this, -1);\n            var result = this.value.shift();\n            move();\n            return result;\n        };\n        Pp.unshift = function unshift(...args) {\n            var move = getMoves(this, args.length);\n            var result = this.value.unshift.apply(this.value, args);\n            move();\n            return result;\n        };\n        Pp.push = function push(...args) {\n            isArray.assert(this.value);\n            delete getChildCache(this).length;\n            return this.value.push.apply(this.value, args);\n        };\n        Pp.pop = function pop() {\n            isArray.assert(this.value);\n            var cache = getChildCache(this);\n            delete cache[this.value.length - 1];\n            delete cache.length;\n            return this.value.pop();\n        };\n        Pp.insertAt = function insertAt(index) {\n            var argc = arguments.length;\n            var move = getMoves(this, argc - 1, index);\n            if (move === emptyMoves && argc <= 1) {\n                return this;\n            }\n            index = Math.max(index, 0);\n            for (var i = 1; i < argc; ++i) {\n                this.value[index + i - 1] = arguments[i];\n            }\n            move();\n            return this;\n        };\n        Pp.insertBefore = function insertBefore(...args) {\n            var pp = this.parentPath;\n            var argc = args.length;\n            var insertAtArgs = [this.name];\n            for (var i = 0; i < argc; ++i) {\n                insertAtArgs.push(args[i]);\n            }\n            return pp.insertAt.apply(pp, insertAtArgs);\n        };\n        Pp.insertAfter = function insertAfter(...args) {\n            var pp = this.parentPath;\n            var argc = args.length;\n            var insertAtArgs = [this.name + 1];\n            for (var i = 0; i < argc; ++i) {\n                insertAtArgs.push(args[i]);\n            }\n            return pp.insertAt.apply(pp, insertAtArgs);\n        };\n        function repairRelationshipWithParent(path) {\n            if (!(path instanceof Path)) {\n                throw new Error('');\n            }\n            var pp = path.parentPath;\n            if (!pp) {\n                return path;\n            }\n            var parentValue = pp.value;\n            var parentCache = getChildCache(pp);\n            if (parentValue[path.name] === path.value) {\n                parentCache[path.name] = path;\n            } else if (isArray.check(parentValue)) {\n                var i = parentValue.indexOf(path.value);\n                if (i >= 0) {\n                    parentCache[path.name = i] = path;\n                }\n            } else {\n                parentValue[path.name] = path.value;\n                parentCache[path.name] = path;\n            }\n            if (parentValue[path.name] !== path.value) {\n                throw new Error('');\n            }\n            if (path.parentPath.get(path.name) !== path) {\n                throw new Error('');\n            }\n            return path;\n        }\n        Pp.replace = function replace(replacement) {\n            var results = [];\n            var parentValue = this.parentPath.value;\n            var parentCache = getChildCache(this.parentPath);\n            var count = arguments.length;\n            repairRelationshipWithParent(this);\n            if (isArray.check(parentValue)) {\n                var originalLength = parentValue.length;\n                var move = getMoves(this.parentPath, count - 1, this.name + 1);\n                var spliceArgs = [\n                    this.name,\n                    1\n                ];\n                for (var i = 0; i < count; ++i) {\n                    spliceArgs.push(arguments[i]);\n                }\n                var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);\n                if (splicedOut[0] !== this.value) {\n                    throw new Error('');\n                }\n                if (parentValue.length !== originalLength - 1 + count) {\n                    throw new Error('');\n                }\n                move();\n                if (count === 0) {\n                    delete this.value;\n                    delete parentCache[this.name];\n                    this.__childCache = null;\n                } else {\n                    if (parentValue[this.name] !== replacement) {\n                        throw new Error('');\n                    }\n                    if (this.value !== replacement) {\n                        this.value = replacement;\n                        this.__childCache = null;\n                    }\n                    for (i = 0; i < count; ++i) {\n                        results.push(this.parentPath.get(this.name + i));\n                    }\n                    if (results[0] !== this) {\n                        throw new Error('');\n                    }\n                }\n            } else if (count === 1) {\n                if (this.value !== replacement) {\n                    this.__childCache = null;\n                }\n                this.value = parentValue[this.name] = replacement;\n                results.push(this);\n            } else if (count === 0) {\n                delete parentValue[this.name];\n                delete this.value;\n                this.__childCache = null;\n            } else {\n                throw new Error('Could not replace path');\n            }\n            return results;\n        };\n        return Path;\n    };\n});"]}