{"version":3,"sources":["path.js"],"names":["define","typesPlugin","hasOwn","Object","prototype","hasOwnProperty","fork","types","use","isArray","builtInTypes","array","isNumber","number","Path","value","parentPath","name","this","Error","__childCache","Pp","getChildCache","path","create","getChildPath","cache","actualChildValue","getValueProperty","childPath","call","constructor","emptyMoves","getMoves","offset","start","end","assert","length","argc","arguments","Math","max","min","moves","i","get","newIndex","names","count","each","callback","context","childPaths","len","map","result","push","filter","shift","move","unshift","args","apply","pop","insertAt","index","insertBefore","pp","insertAtArgs","insertAfter","replace","replacement","results","parentValue","parentCache","check","indexOf","repairRelationshipWithParent","originalLength","spliceArgs","splice"],"mappings":"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","file":"../path.js","sourcesContent":["define(['./types'], function (typesPlugin) {\n    'use strict';\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    return function pathPlugin(fork) {\n        var types = fork.use(typesPlugin);\n        var isArray = types.builtInTypes.array;\n        var isNumber = types.builtInTypes.number;\n        const Path = function Path(value, parentPath, name) {\n            if (!(this instanceof Path)) {\n                throw new Error(\"Path constructor cannot be invoked without 'new'\");\n            }\n            if (parentPath) {\n                if (!(parentPath instanceof Path)) {\n                    throw new Error('');\n                }\n            } else {\n                parentPath = null;\n                name = null;\n            }\n            this.value = value;\n            this.parentPath = parentPath;\n            this.name = name;\n            this.__childCache = null;\n        };\n        var Pp = Path.prototype;\n        function getChildCache(path) {\n            return path.__childCache || (path.__childCache = Object.create(null));\n        }\n        function getChildPath(path, name) {\n            var cache = getChildCache(path);\n            var actualChildValue = path.getValueProperty(name);\n            var childPath = cache[name];\n            if (!hasOwn.call(cache, name) || childPath.value !== actualChildValue) {\n                childPath = cache[name] = new path.constructor(actualChildValue, path, name);\n            }\n            return childPath;\n        }\n        Pp.getValueProperty = function getValueProperty(name) {\n            return this.value[name];\n        };\n        Pp.get = function get(...names) {\n            var path = this;\n            var count = names.length;\n            for (var i = 0; i < count; ++i) {\n                path = getChildPath(path, names[i]);\n            }\n            return path;\n        };\n        Pp.each = function each(callback, context) {\n            var childPaths = [];\n            var len = this.value.length;\n            var i = 0;\n            for (var i = 0; i < len; ++i) {\n                if (hasOwn.call(this.value, i)) {\n                    childPaths[i] = this.get(i);\n                }\n            }\n            context = context || this;\n            for (i = 0; i < len; ++i) {\n                if (hasOwn.call(childPaths, i)) {\n                    callback.call(context, childPaths[i]);\n                }\n            }\n        };\n        Pp.map = function map(callback, context) {\n            var result = [];\n            this.each(function (childPath) {\n                result.push(callback.call(this, childPath));\n            }, context);\n            return result;\n        };\n        Pp.filter = function filter(callback, context) {\n            var result = [];\n            this.each(function (childPath) {\n                if (callback.call(this, childPath)) {\n                    result.push(childPath);\n                }\n            }, context);\n            return result;\n        };\n        function emptyMoves() {\n        }\n        function getMoves(path, offset, start, end) {\n            isArray.assert(path.value);\n            if (offset === 0) {\n                return emptyMoves;\n            }\n            var length = path.value.length;\n            if (length < 1) {\n                return emptyMoves;\n            }\n            var argc = arguments.length;\n            if (argc === 2) {\n                start = 0;\n                end = length;\n            } else if (argc === 3) {\n                start = Math.max(start, 0);\n                end = length;\n            } else {\n                start = Math.max(start, 0);\n                end = Math.min(end, length);\n            }\n            isNumber.assert(start);\n            isNumber.assert(end);\n            var moves = Object.create(null);\n            var cache = getChildCache(path);\n            for (var i = start; i < end; ++i) {\n                if (hasOwn.call(path.value, i)) {\n                    var childPath = path.get(i);\n                    if (childPath.name !== i) {\n                        throw new Error('');\n                    }\n                    var newIndex = i + offset;\n                    childPath.name = newIndex;\n                    moves[newIndex] = childPath;\n                    delete cache[i];\n                }\n            }\n            delete cache.length;\n            return function () {\n                for (var newIndex in moves) {\n                    var childPath = moves[newIndex];\n                    if (childPath.name !== +newIndex) {\n                        throw new Error('');\n                    }\n                    cache[newIndex] = childPath;\n                    path.value[newIndex] = childPath.value;\n                }\n            };\n        }\n        Pp.shift = function shift() {\n            var move = getMoves(this, -1);\n            var result = this.value.shift();\n            move();\n            return result;\n        };\n        Pp.unshift = function unshift(...args) {\n            var move = getMoves(this, args.length);\n            var result = this.value.unshift.apply(this.value, args);\n            move();\n            return result;\n        };\n        Pp.push = function push(...args) {\n            isArray.assert(this.value);\n            delete getChildCache(this).length;\n            return this.value.push.apply(this.value, args);\n        };\n        Pp.pop = function pop() {\n            isArray.assert(this.value);\n            var cache = getChildCache(this);\n            delete cache[this.value.length - 1];\n            delete cache.length;\n            return this.value.pop();\n        };\n        Pp.insertAt = function insertAt(index) {\n            var argc = arguments.length;\n            var move = getMoves(this, argc - 1, index);\n            if (move === emptyMoves && argc <= 1) {\n                return this;\n            }\n            index = Math.max(index, 0);\n            for (var i = 1; i < argc; ++i) {\n                this.value[index + i - 1] = arguments[i];\n            }\n            move();\n            return this;\n        };\n        Pp.insertBefore = function insertBefore(...args) {\n            var pp = this.parentPath;\n            var argc = args.length;\n            var insertAtArgs = [this.name];\n            for (var i = 0; i < argc; ++i) {\n                insertAtArgs.push(args[i]);\n            }\n            return pp.insertAt.apply(pp, insertAtArgs);\n        };\n        Pp.insertAfter = function insertAfter(...args) {\n            var pp = this.parentPath;\n            var argc = args.length;\n            var insertAtArgs = [this.name + 1];\n            for (var i = 0; i < argc; ++i) {\n                insertAtArgs.push(args[i]);\n            }\n            return pp.insertAt.apply(pp, insertAtArgs);\n        };\n        function repairRelationshipWithParent(path) {\n            if (!(path instanceof Path)) {\n                throw new Error('');\n            }\n            var pp = path.parentPath;\n            if (!pp) {\n                return path;\n            }\n            var parentValue = pp.value;\n            var parentCache = getChildCache(pp);\n            if (parentValue[path.name] === path.value) {\n                parentCache[path.name] = path;\n            } else if (isArray.check(parentValue)) {\n                var i = parentValue.indexOf(path.value);\n                if (i >= 0) {\n                    parentCache[path.name = i] = path;\n                }\n            } else {\n                parentValue[path.name] = path.value;\n                parentCache[path.name] = path;\n            }\n            if (parentValue[path.name] !== path.value) {\n                throw new Error('');\n            }\n            if (path.parentPath.get(path.name) !== path) {\n                throw new Error('');\n            }\n            return path;\n        }\n        Pp.replace = function replace(replacement) {\n            var results = [];\n            var parentValue = this.parentPath.value;\n            var parentCache = getChildCache(this.parentPath);\n            var count = arguments.length;\n            repairRelationshipWithParent(this);\n            if (isArray.check(parentValue)) {\n                var originalLength = parentValue.length;\n                var move = getMoves(this.parentPath, count - 1, this.name + 1);\n                var spliceArgs = [\n                    this.name,\n                    1\n                ];\n                for (var i = 0; i < count; ++i) {\n                    spliceArgs.push(arguments[i]);\n                }\n                var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);\n                if (splicedOut[0] !== this.value) {\n                    throw new Error('');\n                }\n                if (parentValue.length !== originalLength - 1 + count) {\n                    throw new Error('');\n                }\n                move();\n                if (count === 0) {\n                    delete this.value;\n                    delete parentCache[this.name];\n                    this.__childCache = null;\n                } else {\n                    if (parentValue[this.name] !== replacement) {\n                        throw new Error('');\n                    }\n                    if (this.value !== replacement) {\n                        this.value = replacement;\n                        this.__childCache = null;\n                    }\n                    for (i = 0; i < count; ++i) {\n                        results.push(this.parentPath.get(this.name + i));\n                    }\n                    if (results[0] !== this) {\n                        throw new Error('');\n                    }\n                }\n            } else if (count === 1) {\n                if (this.value !== replacement) {\n                    this.__childCache = null;\n                }\n                this.value = parentValue[this.name] = replacement;\n                results.push(this);\n            } else if (count === 0) {\n                delete parentValue[this.name];\n                delete this.value;\n                this.__childCache = null;\n            } else {\n                throw new Error('Could not replace path');\n            }\n            return results;\n        };\n        return Path;\n    };\n});"]}