{"version":3,"sources":["node-path.js"],"names":["define","typesPlugin","pathPlugin","scopePlugin","fork","NodePath","value","parentPath","name","this","Error","Path","call","types","use","n","namedTypes","b","builders","isNumber","builtInTypes","number","isArray","array","Scope","NPp","prototype","Object","create","constructor","enumerable","writable","configurable","defineProperties","node","get","defineProperty","_computeNode","parent","_computeParent","scope","_computeScope","replace","apply","arguments","prune","remainingNodePath","VariableDeclaration","check","declarations","length","ExpressionStatement","IfStatement","cleanUpIfStatementAfterPrune","ifStatement","testExpression","alternate","consequent","negatedTestExpression","unaryExpression","UnaryExpression","operator","argument","testExpressionStatement","expressionStatement","Node","pp","isEstablishedBy","getValueProperty","getFieldValue","needsParens","assumeExpressionContext","Expression","type","object","callee","po","PRECEDENCE","no","np","right","test","containsCallExpression","canBeFirstInStatement","firstInStatement","CallExpression","some","someField","_name","child","forEach","tier","i","op","FunctionExpression","ObjectExpression","path","BlockStatement","body","expression","SequenceExpression","expressions","MemberExpression","ConditionalExpression","BinaryExpression","LogicalExpression","left","prefix"],"mappings":"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","file":"../node-path.js","sourcesContent":["define([\n    './types',\n    './path',\n    './scope'\n], function (typesPlugin, pathPlugin, scopePlugin) {\n    'use strict';\n    return function nodePathPlugin(fork) {\n        var types = fork.use(typesPlugin);\n        var n = types.namedTypes;\n        var b = types.builders;\n        var isNumber = types.builtInTypes.number;\n        var isArray = types.builtInTypes.array;\n        var Path = fork.use(pathPlugin);\n        var Scope = fork.use(scopePlugin);\n        const NodePath = function NodePath(value, parentPath, name) {\n            if (!(this instanceof NodePath)) {\n                throw new Error(\"NodePath constructor cannot be invoked without 'new'\");\n            }\n            Path.call(this, value, parentPath, name);\n        };\n        var NPp = NodePath.prototype = Object.create(Path.prototype, {\n            constructor: {\n                value: NodePath,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        Object.defineProperties(NPp, {\n            node: {\n                get: function () {\n                    Object.defineProperty(this, 'node', {\n                        configurable: true,\n                        value: this._computeNode()\n                    });\n                    return this.node;\n                }\n            },\n            parent: {\n                get: function () {\n                    Object.defineProperty(this, 'parent', {\n                        configurable: true,\n                        value: this._computeParent()\n                    });\n                    return this.parent;\n                }\n            },\n            scope: {\n                get: function () {\n                    Object.defineProperty(this, 'scope', {\n                        configurable: true,\n                        value: this._computeScope()\n                    });\n                    return this.scope;\n                }\n            }\n        });\n        NPp.replace = function () {\n            delete this.node;\n            delete this.parent;\n            delete this.scope;\n            return Path.prototype.replace.apply(this, arguments);\n        };\n        NPp.prune = function () {\n            var remainingNodePath = this.parent;\n            this.replace();\n            return cleanUpNodesAfterPrune(remainingNodePath);\n        };\n        NPp._computeNode = function () {\n            var value = this.value;\n            if (n.Node.check(value)) {\n                return value;\n            }\n            var pp = this.parentPath;\n            return pp && pp.node || null;\n        };\n        NPp._computeParent = function () {\n            var value = this.value;\n            var pp = this.parentPath;\n            if (!n.Node.check(value)) {\n                while (pp && !n.Node.check(pp.value)) {\n                    pp = pp.parentPath;\n                }\n                if (pp) {\n                    pp = pp.parentPath;\n                }\n            }\n            while (pp && !n.Node.check(pp.value)) {\n                pp = pp.parentPath;\n            }\n            return pp || null;\n        };\n        NPp._computeScope = function () {\n            var value = this.value;\n            var pp = this.parentPath;\n            var scope = pp && pp.scope;\n            if (n.Node.check(value) && Scope.isEstablishedBy(value)) {\n                scope = new Scope(this, scope);\n            }\n            return scope || null;\n        };\n        NPp.getValueProperty = function (name) {\n            return types.getFieldValue(this.value, name);\n        };\n        NPp.needsParens = function (assumeExpressionContext) {\n            var pp = this.parentPath;\n            if (!pp) {\n                return false;\n            }\n            var node = this.value;\n            if (!n.Expression.check(node)) {\n                return false;\n            }\n            if (node.type === 'Identifier') {\n                return false;\n            }\n            while (!n.Node.check(pp.value)) {\n                pp = pp.parentPath;\n                if (!pp) {\n                    return false;\n                }\n            }\n            var parent = pp.value;\n            switch (node.type) {\n            case 'UnaryExpression':\n            case 'SpreadElement':\n            case 'SpreadProperty':\n                return parent.type === 'MemberExpression' && this.name === 'object' && parent.object === node;\n            case 'BinaryExpression':\n            case 'LogicalExpression':\n                switch (parent.type) {\n                case 'CallExpression':\n                    return this.name === 'callee' && parent.callee === node;\n                case 'UnaryExpression':\n                case 'SpreadElement':\n                case 'SpreadProperty':\n                    return true;\n                case 'MemberExpression':\n                    return this.name === 'object' && parent.object === node;\n                case 'BinaryExpression':\n                case 'LogicalExpression': {\n                        const n = node;\n                        const po = parent.operator;\n                        const pp = PRECEDENCE[po];\n                        const no = n.operator;\n                        const np = PRECEDENCE[no];\n                        if (pp > np) {\n                            return true;\n                        }\n                        if (pp === np && this.name === 'right') {\n                            if (parent.right !== n) {\n                                throw new Error('Nodes must be equal');\n                            }\n                            return true;\n                        }\n                    }\n                default:\n                    return false;\n                }\n            case 'SequenceExpression':\n                switch (parent.type) {\n                case 'ForStatement':\n                    return false;\n                case 'ExpressionStatement':\n                    return this.name !== 'expression';\n                default:\n                    return true;\n                }\n            case 'YieldExpression':\n                switch (parent.type) {\n                case 'BinaryExpression':\n                case 'LogicalExpression':\n                case 'UnaryExpression':\n                case 'SpreadElement':\n                case 'SpreadProperty':\n                case 'CallExpression':\n                case 'MemberExpression':\n                case 'NewExpression':\n                case 'ConditionalExpression':\n                case 'YieldExpression':\n                    return true;\n                default:\n                    return false;\n                }\n            case 'Literal':\n                return parent.type === 'MemberExpression' && isNumber.check(node.value) && this.name === 'object' && parent.object === node;\n            case 'AssignmentExpression':\n            case 'ConditionalExpression':\n                switch (parent.type) {\n                case 'UnaryExpression':\n                case 'SpreadElement':\n                case 'SpreadProperty':\n                case 'BinaryExpression':\n                case 'LogicalExpression':\n                    return true;\n                case 'CallExpression':\n                    return this.name === 'callee' && parent.callee === node;\n                case 'ConditionalExpression':\n                    return this.name === 'test' && parent.test === node;\n                case 'MemberExpression':\n                    return this.name === 'object' && parent.object === node;\n                default:\n                    return false;\n                }\n            default:\n                if (parent.type === 'NewExpression' && this.name === 'callee' && parent.callee === node) {\n                    return containsCallExpression(node);\n                }\n            }\n            if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement())\n                return true;\n            return false;\n        };\n        function isBinary(node) {\n            return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);\n        }\n        function isUnaryLike(node) {\n            return n.UnaryExpression.check(node) || n.SpreadElement && n.SpreadElement.check(node) || n.SpreadProperty && n.SpreadProperty.check(node);\n        }\n        var PRECEDENCE = {};\n        [\n            ['||'],\n            ['&&'],\n            ['|'],\n            ['^'],\n            ['&'],\n            [\n                '==',\n                '===',\n                '!=',\n                '!=='\n            ],\n            [\n                '<',\n                '>',\n                '<=',\n                '>=',\n                'in',\n                'instanceof'\n            ],\n            [\n                '>>',\n                '<<',\n                '>>>'\n            ],\n            [\n                '+',\n                '-'\n            ],\n            [\n                '*',\n                '/',\n                '%'\n            ]\n        ].forEach(function (tier, i) {\n            tier.forEach(function (op) {\n                PRECEDENCE[op] = i;\n            });\n        });\n        function containsCallExpression(node) {\n            if (n.CallExpression.check(node)) {\n                return true;\n            }\n            if (isArray.check(node)) {\n                return node.some(containsCallExpression);\n            }\n            if (n.Node.check(node)) {\n                return types.someField(node, function (_name, child) {\n                    return containsCallExpression(child);\n                });\n            }\n            return false;\n        }\n        NPp.canBeFirstInStatement = function () {\n            var node = this.node;\n            return !n.FunctionExpression.check(node) && !n.ObjectExpression.check(node);\n        };\n        NPp.firstInStatement = function () {\n            return firstInStatement(this);\n        };\n        function firstInStatement(path) {\n            for (var node, parent; path.parent; path = path.parent) {\n                node = path.node;\n                parent = path.parent.node;\n                if (n.BlockStatement.check(parent) && path.parent.name === 'body' && path.name === 0) {\n                    if (parent.body[0] !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    return true;\n                }\n                if (n.ExpressionStatement.check(parent) && path.name === 'expression') {\n                    if (parent.expression !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    return true;\n                }\n                if (n.SequenceExpression.check(parent) && path.parent.name === 'expressions' && path.name === 0) {\n                    if (parent.expressions[0] !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    continue;\n                }\n                if (n.CallExpression.check(parent) && path.name === 'callee') {\n                    if (parent.callee !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    continue;\n                }\n                if (n.MemberExpression.check(parent) && path.name === 'object') {\n                    if (parent.object !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    continue;\n                }\n                if (n.ConditionalExpression.check(parent) && path.name === 'test') {\n                    if (parent.test !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    continue;\n                }\n                if (isBinary(parent) && path.name === 'left') {\n                    if (parent.left !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    continue;\n                }\n                if (n.UnaryExpression.check(parent) && !parent.prefix && path.name === 'argument') {\n                    if (parent.argument !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        function cleanUpNodesAfterPrune(remainingNodePath) {\n            if (n.VariableDeclaration.check(remainingNodePath.node)) {\n                var declarations = remainingNodePath.get('declarations').value;\n                if (!declarations || declarations.length === 0) {\n                    return remainingNodePath.prune();\n                }\n            } else if (n.ExpressionStatement.check(remainingNodePath.node)) {\n                if (!remainingNodePath.get('expression').value) {\n                    return remainingNodePath.prune();\n                }\n            } else if (n.IfStatement.check(remainingNodePath.node)) {\n                cleanUpIfStatementAfterPrune(remainingNodePath);\n            }\n            return remainingNodePath;\n        }\n        function cleanUpIfStatementAfterPrune(ifStatement) {\n            var testExpression = ifStatement.get('test').value;\n            var alternate = ifStatement.get('alternate').value;\n            var consequent = ifStatement.get('consequent').value;\n            if (!consequent && !alternate) {\n                var testExpressionStatement = b.expressionStatement(testExpression);\n                ifStatement.replace(testExpressionStatement);\n            } else if (!consequent && alternate) {\n                var negatedTestExpression = b.unaryExpression('!', testExpression, true);\n                if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {\n                    negatedTestExpression = testExpression.argument;\n                }\n                ifStatement.get('test').replace(negatedTestExpression);\n                ifStatement.get('consequent').replace(alternate);\n                ifStatement.get('alternate').replace();\n            }\n        }\n        return NodePath;\n    };\n});"]}