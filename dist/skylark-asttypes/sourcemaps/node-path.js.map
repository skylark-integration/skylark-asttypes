{"version":3,"sources":["node-path.js"],"names":["define","typesPlugin","pathPlugin","scopePlugin","fork","types","use","n","namedTypes","b","builders","isNumber","builtInTypes","number","isArray","array","Path","Scope","NodePath","value","parentPath","name","this","Error","call","NPp","prototype","Object","create","constructor","enumerable","writable","configurable","isBinary","node","BinaryExpression","check","LogicalExpression","defineProperties","get","defineProperty","_computeNode","parent","_computeParent","scope","_computeScope","replace","apply","arguments","prune","remainingNodePath","VariableDeclaration","declarations","length","ExpressionStatement","IfStatement","ifStatement","testExpression","alternate","consequent","negatedTestExpression","unaryExpression","UnaryExpression","operator","argument","testExpressionStatement","expressionStatement","cleanUpIfStatementAfterPrune","cleanUpNodesAfterPrune","Node","pp","isEstablishedBy","getValueProperty","getFieldValue","needsParens","assumeExpressionContext","Expression","type","object","callee","po","PRECEDENCE","no","np","right","test","containsCallExpression","canBeFirstInStatement","firstInStatement","CallExpression","some","someField","_name","child","forEach","tier","i","op","FunctionExpression","ObjectExpression","path","BlockStatement","body","expression","SequenceExpression","expressions","MemberExpression","ConditionalExpression","left","prefix"],"mappings":"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","file":"../node-path.js","sourcesContent":["define([\n    './types',\n    './path',\n    './scope'\n], function (typesPlugin, pathPlugin, scopePlugin) {\n    'use strict';\n    return function nodePathPlugin(fork) {\n        var types = fork.use(typesPlugin);\n        var n = types.namedTypes;\n        var b = types.builders;\n        var isNumber = types.builtInTypes.number;\n        var isArray = types.builtInTypes.array;\n        var Path = fork.use(pathPlugin);\n        var Scope = fork.use(scopePlugin);\n        const NodePath = function NodePath(value, parentPath, name) {\n            if (!(this instanceof NodePath)) {\n                throw new Error(\"NodePath constructor cannot be invoked without 'new'\");\n            }\n            Path.call(this, value, parentPath, name);\n        };\n        var NPp = NodePath.prototype = Object.create(Path.prototype, {\n            constructor: {\n                value: NodePath,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        Object.defineProperties(NPp, {\n            node: {\n                get: function () {\n                    Object.defineProperty(this, 'node', {\n                        configurable: true,\n                        value: this._computeNode()\n                    });\n                    return this.node;\n                }\n            },\n            parent: {\n                get: function () {\n                    Object.defineProperty(this, 'parent', {\n                        configurable: true,\n                        value: this._computeParent()\n                    });\n                    return this.parent;\n                }\n            },\n            scope: {\n                get: function () {\n                    Object.defineProperty(this, 'scope', {\n                        configurable: true,\n                        value: this._computeScope()\n                    });\n                    return this.scope;\n                }\n            }\n        });\n        NPp.replace = function () {\n            delete this.node;\n            delete this.parent;\n            delete this.scope;\n            return Path.prototype.replace.apply(this, arguments);\n        };\n        NPp.prune = function () {\n            var remainingNodePath = this.parent;\n            this.replace();\n            return cleanUpNodesAfterPrune(remainingNodePath);\n        };\n        NPp._computeNode = function () {\n            var value = this.value;\n            if (n.Node.check(value)) {\n                return value;\n            }\n            var pp = this.parentPath;\n            return pp && pp.node || null;\n        };\n        NPp._computeParent = function () {\n            var value = this.value;\n            var pp = this.parentPath;\n            if (!n.Node.check(value)) {\n                while (pp && !n.Node.check(pp.value)) {\n                    pp = pp.parentPath;\n                }\n                if (pp) {\n                    pp = pp.parentPath;\n                }\n            }\n            while (pp && !n.Node.check(pp.value)) {\n                pp = pp.parentPath;\n            }\n            return pp || null;\n        };\n        NPp._computeScope = function () {\n            var value = this.value;\n            var pp = this.parentPath;\n            var scope = pp && pp.scope;\n            if (n.Node.check(value) && Scope.isEstablishedBy(value)) {\n                scope = new Scope(this, scope);\n            }\n            return scope || null;\n        };\n        NPp.getValueProperty = function (name) {\n            return types.getFieldValue(this.value, name);\n        };\n        NPp.needsParens = function (assumeExpressionContext) {\n            var pp = this.parentPath;\n            if (!pp) {\n                return false;\n            }\n            var node = this.value;\n            if (!n.Expression.check(node)) {\n                return false;\n            }\n            if (node.type === 'Identifier') {\n                return false;\n            }\n            while (!n.Node.check(pp.value)) {\n                pp = pp.parentPath;\n                if (!pp) {\n                    return false;\n                }\n            }\n            var parent = pp.value;\n            switch (node.type) {\n            case 'UnaryExpression':\n            case 'SpreadElement':\n            case 'SpreadProperty':\n                return parent.type === 'MemberExpression' && this.name === 'object' && parent.object === node;\n            case 'BinaryExpression':\n            case 'LogicalExpression':\n                switch (parent.type) {\n                case 'CallExpression':\n                    return this.name === 'callee' && parent.callee === node;\n                case 'UnaryExpression':\n                case 'SpreadElement':\n                case 'SpreadProperty':\n                    return true;\n                case 'MemberExpression':\n                    return this.name === 'object' && parent.object === node;\n                case 'BinaryExpression':\n                case 'LogicalExpression': {\n                        const n = node;\n                        const po = parent.operator;\n                        const pp = PRECEDENCE[po];\n                        const no = n.operator;\n                        const np = PRECEDENCE[no];\n                        if (pp > np) {\n                            return true;\n                        }\n                        if (pp === np && this.name === 'right') {\n                            if (parent.right !== n) {\n                                throw new Error('Nodes must be equal');\n                            }\n                            return true;\n                        }\n                    }\n                default:\n                    return false;\n                }\n            case 'SequenceExpression':\n                switch (parent.type) {\n                case 'ForStatement':\n                    return false;\n                case 'ExpressionStatement':\n                    return this.name !== 'expression';\n                default:\n                    return true;\n                }\n            case 'YieldExpression':\n                switch (parent.type) {\n                case 'BinaryExpression':\n                case 'LogicalExpression':\n                case 'UnaryExpression':\n                case 'SpreadElement':\n                case 'SpreadProperty':\n                case 'CallExpression':\n                case 'MemberExpression':\n                case 'NewExpression':\n                case 'ConditionalExpression':\n                case 'YieldExpression':\n                    return true;\n                default:\n                    return false;\n                }\n            case 'Literal':\n                return parent.type === 'MemberExpression' && isNumber.check(node.value) && this.name === 'object' && parent.object === node;\n            case 'AssignmentExpression':\n            case 'ConditionalExpression':\n                switch (parent.type) {\n                case 'UnaryExpression':\n                case 'SpreadElement':\n                case 'SpreadProperty':\n                case 'BinaryExpression':\n                case 'LogicalExpression':\n                    return true;\n                case 'CallExpression':\n                    return this.name === 'callee' && parent.callee === node;\n                case 'ConditionalExpression':\n                    return this.name === 'test' && parent.test === node;\n                case 'MemberExpression':\n                    return this.name === 'object' && parent.object === node;\n                default:\n                    return false;\n                }\n            default:\n                if (parent.type === 'NewExpression' && this.name === 'callee' && parent.callee === node) {\n                    return containsCallExpression(node);\n                }\n            }\n            if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement())\n                return true;\n            return false;\n        };\n        function isBinary(node) {\n            return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);\n        }\n        function isUnaryLike(node) {\n            return n.UnaryExpression.check(node) || n.SpreadElement && n.SpreadElement.check(node) || n.SpreadProperty && n.SpreadProperty.check(node);\n        }\n        var PRECEDENCE = {};\n        [\n            ['||'],\n            ['&&'],\n            ['|'],\n            ['^'],\n            ['&'],\n            [\n                '==',\n                '===',\n                '!=',\n                '!=='\n            ],\n            [\n                '<',\n                '>',\n                '<=',\n                '>=',\n                'in',\n                'instanceof'\n            ],\n            [\n                '>>',\n                '<<',\n                '>>>'\n            ],\n            [\n                '+',\n                '-'\n            ],\n            [\n                '*',\n                '/',\n                '%'\n            ]\n        ].forEach(function (tier, i) {\n            tier.forEach(function (op) {\n                PRECEDENCE[op] = i;\n            });\n        });\n        function containsCallExpression(node) {\n            if (n.CallExpression.check(node)) {\n                return true;\n            }\n            if (isArray.check(node)) {\n                return node.some(containsCallExpression);\n            }\n            if (n.Node.check(node)) {\n                return types.someField(node, function (_name, child) {\n                    return containsCallExpression(child);\n                });\n            }\n            return false;\n        }\n        NPp.canBeFirstInStatement = function () {\n            var node = this.node;\n            return !n.FunctionExpression.check(node) && !n.ObjectExpression.check(node);\n        };\n        NPp.firstInStatement = function () {\n            return firstInStatement(this);\n        };\n        function firstInStatement(path) {\n            for (var node, parent; path.parent; path = path.parent) {\n                node = path.node;\n                parent = path.parent.node;\n                if (n.BlockStatement.check(parent) && path.parent.name === 'body' && path.name === 0) {\n                    if (parent.body[0] !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    return true;\n                }\n                if (n.ExpressionStatement.check(parent) && path.name === 'expression') {\n                    if (parent.expression !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    return true;\n                }\n                if (n.SequenceExpression.check(parent) && path.parent.name === 'expressions' && path.name === 0) {\n                    if (parent.expressions[0] !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    continue;\n                }\n                if (n.CallExpression.check(parent) && path.name === 'callee') {\n                    if (parent.callee !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    continue;\n                }\n                if (n.MemberExpression.check(parent) && path.name === 'object') {\n                    if (parent.object !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    continue;\n                }\n                if (n.ConditionalExpression.check(parent) && path.name === 'test') {\n                    if (parent.test !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    continue;\n                }\n                if (isBinary(parent) && path.name === 'left') {\n                    if (parent.left !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    continue;\n                }\n                if (n.UnaryExpression.check(parent) && !parent.prefix && path.name === 'argument') {\n                    if (parent.argument !== node) {\n                        throw new Error('Nodes must be equal');\n                    }\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        function cleanUpNodesAfterPrune(remainingNodePath) {\n            if (n.VariableDeclaration.check(remainingNodePath.node)) {\n                var declarations = remainingNodePath.get('declarations').value;\n                if (!declarations || declarations.length === 0) {\n                    return remainingNodePath.prune();\n                }\n            } else if (n.ExpressionStatement.check(remainingNodePath.node)) {\n                if (!remainingNodePath.get('expression').value) {\n                    return remainingNodePath.prune();\n                }\n            } else if (n.IfStatement.check(remainingNodePath.node)) {\n                cleanUpIfStatementAfterPrune(remainingNodePath);\n            }\n            return remainingNodePath;\n        }\n        function cleanUpIfStatementAfterPrune(ifStatement) {\n            var testExpression = ifStatement.get('test').value;\n            var alternate = ifStatement.get('alternate').value;\n            var consequent = ifStatement.get('consequent').value;\n            if (!consequent && !alternate) {\n                var testExpressionStatement = b.expressionStatement(testExpression);\n                ifStatement.replace(testExpressionStatement);\n            } else if (!consequent && alternate) {\n                var negatedTestExpression = b.unaryExpression('!', testExpression, true);\n                if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {\n                    negatedTestExpression = testExpression.argument;\n                }\n                ifStatement.get('test').replace(negatedTestExpression);\n                ifStatement.get('consequent').replace(alternate);\n                ifStatement.get('alternate').replace();\n            }\n        }\n        return NodePath;\n    };\n});"]}