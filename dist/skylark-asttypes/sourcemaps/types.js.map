{"version":3,"sources":["types.js"],"names":["define","Op","Object","prototype","objToStr","toString","hasOwn","hasOwnProperty","BaseType","[object Object]","value","deep","this","check","str","shallowStringify","Error","ArrayType","elemType","super","kind","Array","isArray","every","elem","IdentityType","String","result","ObjectType","fields","join","call","field","type","name","OrType","types","some","PredicateType","predicate","Def","typeName","baseNames","ownFields","create","allSupertypes","supertypeList","allFields","fieldNames","finalized","buildable","buildParams","that","keys","child","getValue","supertypeNames","bases","length","i","forEach","baseName","indexOf","push","Field","defaultFn","hidden","JSON","stringify","obj","map","key","_fork","Type","or","from","isObject","bicfIndex","builtInCtorFns","builtInCtorTypes","def","defCache","vDef","defFromValue","checkAllFields","isSupertypeOf","addParam","built","param","arg","isArgAvailable","all","message","builder","args","argc","nodePrototype","defineProperty","builders","getBuilderName","enumerable","console","error","fieldName","finalize","extend","namedTypes","list","lastSeen","pos","d","apply","to","len","populateSupertypeList","lastIndexOf","wrapperName","getStatementBuilderName","wrapped","expressionStatement","wrapExpressionBuilderWithStatement","hasDef","defBuiltInType","example","objStr","constructor","isString","isFunction","isRegExp","isDate","Date","isNumber","isBoolean","isNull","isUndefined","undefined","isBigInt","BigInt","builtInTypes","string","function","array","object","RegExp","number","boolean","null","replace","upperCasePrefix","toLowerCase","slice","charAt","getFieldNames","getFieldValue","into","getSupertypeNames","computeSupertypeLookupTable","candidates","table","typeNames","typeNameCount","j","superTypeName","defineMethod","func","old","assert","configurable","eachField","callback","context","someField"],"mappings":"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","file":"../types.js","sourcesContent":["define(function () {\n    'use strict';\n    const Op = Object.prototype;\n    const objToStr = Op.toString;\n    const hasOwn = Op.hasOwnProperty;\n    class BaseType {\n        assert(value, deep) {\n            if (!this.check(value, deep)) {\n                var str = shallowStringify(value);\n                throw new Error(str + ' does not match type ' + this);\n            }\n            return true;\n        }\n        arrayOf() {\n            const elemType = this;\n            return new ArrayType(elemType);\n        }\n    }\n    class ArrayType extends BaseType {\n        constructor(elemType) {\n            super();\n            this.elemType = elemType;\n            this.kind = 'ArrayType';\n        }\n        toString() {\n            return '[' + this.elemType + ']';\n        }\n        check(value, deep) {\n            return Array.isArray(value) && value.every(elem => this.elemType.check(elem, deep));\n        }\n    }\n    class IdentityType extends BaseType {\n        constructor(value) {\n            super();\n            this.value = value;\n            this.kind = 'IdentityType';\n        }\n        toString() {\n            return String(this.value);\n        }\n        check(value, deep) {\n            const result = value === this.value;\n            if (!result && typeof deep === 'function') {\n                deep(this, value);\n            }\n            return result;\n        }\n    }\n    class ObjectType extends BaseType {\n        constructor(fields) {\n            super();\n            this.fields = fields;\n            this.kind = 'ObjectType';\n        }\n        toString() {\n            return '{ ' + this.fields.join(', ') + ' }';\n        }\n        check(value, deep) {\n            return objToStr.call(value) === objToStr.call({}) && this.fields.every(field => {\n                return field.type.check(value[field.name], deep);\n            });\n        }\n    }\n    class OrType extends BaseType {\n        constructor(types) {\n            super();\n            this.types = types;\n            this.kind = 'OrType';\n        }\n        toString() {\n            return this.types.join(' | ');\n        }\n        check(value, deep) {\n            if (this.types.some(type => type.check(value, !!deep))) {\n                return true;\n            }\n            if (typeof deep === 'function') {\n                deep(this, value);\n            }\n            return false;\n        }\n    }\n    class PredicateType extends BaseType {\n        constructor(name, predicate) {\n            super();\n            this.name = name;\n            this.predicate = predicate;\n            this.kind = 'PredicateType';\n        }\n        toString() {\n            return this.name;\n        }\n        check(value, deep) {\n            const result = this.predicate(value, deep);\n            if (!result && typeof deep === 'function') {\n                deep(this, value);\n            }\n            return result;\n        }\n    }\n    class Def {\n        constructor(type, typeName) {\n            this.type = type;\n            this.typeName = typeName;\n            this.baseNames = [];\n            this.ownFields = Object.create(null);\n            this.allSupertypes = Object.create(null);\n            this.supertypeList = [];\n            this.allFields = Object.create(null);\n            this.fieldNames = [];\n            this.finalized = false;\n            this.buildable = false;\n            this.buildParams = [];\n        }\n        isSupertypeOf(that) {\n            if (that instanceof Def) {\n                if (this.finalized !== true || that.finalized !== true) {\n                    throw new Error('');\n                }\n                return hasOwn.call(that.allSupertypes, this.typeName);\n            } else {\n                throw new Error(that + ' is not a Def');\n            }\n        }\n        checkAllFields(value, deep) {\n            var allFields = this.allFields;\n            if (this.finalized !== true) {\n                throw new Error('' + this.typeName);\n            }\n            function checkFieldByName(name) {\n                var field = allFields[name];\n                var type = field.type;\n                var child = field.getValue(value);\n                return type.check(child, deep);\n            }\n            return value !== null && typeof value === 'object' && Object.keys(allFields).every(checkFieldByName);\n        }\n        bases(...supertypeNames) {\n            var bases = this.baseNames;\n            if (this.finalized) {\n                if (supertypeNames.length !== bases.length) {\n                    throw new Error('');\n                }\n                for (var i = 0; i < supertypeNames.length; i++) {\n                    if (supertypeNames[i] !== bases[i]) {\n                        throw new Error('');\n                    }\n                }\n                return this;\n            }\n            supertypeNames.forEach(baseName => {\n                if (bases.indexOf(baseName) < 0) {\n                    bases.push(baseName);\n                }\n            });\n            return this;\n        }\n    }\n    class Field {\n        constructor(name, type, defaultFn, hidden) {\n            this.name = name;\n            this.type = type;\n            this.defaultFn = defaultFn;\n            this.hidden = !!hidden;\n        }\n        toString() {\n            return JSON.stringify(this.name) + ': ' + this.type;\n        }\n        getValue(obj) {\n            var value = obj[this.name];\n            if (typeof value !== 'undefined') {\n                return value;\n            }\n            if (typeof this.defaultFn === 'function') {\n                value = this.defaultFn.call(obj);\n            }\n            return value;\n        }\n    }\n    function shallowStringify(value) {\n        if (Array.isArray(value)) {\n            return '[' + value.map(shallowStringify).join(', ') + ']';\n        }\n        if (value && typeof value === 'object') {\n            return '{ ' + Object.keys(value).map(function (key) {\n                return key + ': ' + value[key];\n            }).join(', ') + ' }';\n        }\n        return JSON.stringify(value);\n    }\n    \n    function typesPlugin(_fork) {\n        const Type = {\n            or(...types) {\n                return new OrType(types.map(type => Type.from(type)));\n            },\n            from(value, name) {\n                if (value instanceof ArrayType || value instanceof IdentityType || value instanceof ObjectType || value instanceof OrType || value instanceof PredicateType) {\n                    return value;\n                }\n                if (value instanceof Def) {\n                    return value.type;\n                }\n                if (isArray.check(value)) {\n                    if (value.length !== 1) {\n                        throw new Error('only one element type is permitted for typed arrays');\n                    }\n                    return new ArrayType(Type.from(value[0]));\n                }\n                if (isObject.check(value)) {\n                    return new ObjectType(Object.keys(value).map(name => {\n                        return new Field(name, Type.from(value[name], name));\n                    }));\n                }\n                if (typeof value === 'function') {\n                    var bicfIndex = builtInCtorFns.indexOf(value);\n                    if (bicfIndex >= 0) {\n                        return builtInCtorTypes[bicfIndex];\n                    }\n                    if (typeof name !== 'string') {\n                        throw new Error('missing name');\n                    }\n                    return new PredicateType(name, value);\n                }\n                return new IdentityType(value);\n            },\n            def(typeName) {\n                return hasOwn.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);\n            },\n            hasDef(typeName) {\n                return hasOwn.call(defCache, typeName);\n            }\n        };\n        var builtInCtorFns = [];\n        var builtInCtorTypes = [];\n        function defBuiltInType(name, example) {\n            const objStr = objToStr.call(example);\n            const type = new PredicateType(name, value => objToStr.call(value) === objStr);\n            if (example && typeof example.constructor === 'function') {\n                builtInCtorFns.push(example.constructor);\n                builtInCtorTypes.push(type);\n            }\n            return type;\n        }\n        const isString = defBuiltInType('string', 'truthy');\n        const isFunction = defBuiltInType('function', function () {\n        });\n        const isArray = defBuiltInType('array', []);\n        const isObject = defBuiltInType('object', {});\n        const isRegExp = defBuiltInType('RegExp', /./);\n        const isDate = defBuiltInType('Date', new Date());\n        const isNumber = defBuiltInType('number', 3);\n        const isBoolean = defBuiltInType('boolean', true);\n        const isNull = defBuiltInType('null', null);\n        const isUndefined = defBuiltInType('undefined', undefined);\n        const isBigInt = typeof BigInt === 'function' ? defBuiltInType('BigInt', BigInt(1234)) : new PredicateType('BigInt', () => false);\n        const builtInTypes = {\n            string: isString,\n            function: isFunction,\n            array: isArray,\n            object: isObject,\n            RegExp: isRegExp,\n            Date: isDate,\n            number: isNumber,\n            boolean: isBoolean,\n            null: isNull,\n            undefined: isUndefined,\n            BigInt: isBigInt\n        };\n        var defCache = Object.create(null);\n        function defFromValue(value) {\n            if (value && typeof value === 'object') {\n                var type = value.type;\n                if (typeof type === 'string' && hasOwn.call(defCache, type)) {\n                    var d = defCache[type];\n                    if (d.finalized) {\n                        return d;\n                    }\n                }\n            }\n            return null;\n        }\n        class DefImpl extends Def {\n            constructor(typeName) {\n                super(new PredicateType(typeName, (value, deep) => this.check(value, deep)), typeName);\n            }\n            check(value, deep) {\n                if (this.finalized !== true) {\n                    throw new Error('prematurely checking unfinalized type ' + this.typeName);\n                }\n                if (value === null || typeof value !== 'object') {\n                    return false;\n                }\n                var vDef = defFromValue(value);\n                if (!vDef) {\n                    if (this.typeName === 'SourceLocation' || this.typeName === 'Position') {\n                        return this.checkAllFields(value, deep);\n                    }\n                    return false;\n                }\n                if (deep && vDef === this) {\n                    return this.checkAllFields(value, deep);\n                }\n                if (!this.isSupertypeOf(vDef)) {\n                    return false;\n                }\n                if (!deep) {\n                    return true;\n                }\n                return vDef.checkAllFields(value, deep) && this.checkAllFields(value, false);\n            }\n            build(...buildParams) {\n                this.buildParams = buildParams;\n                if (this.buildable) {\n                    return this;\n                }\n                this.field('type', String, () => this.typeName);\n                this.buildable = true;\n                const addParam = (built, param, arg, isArgAvailable) => {\n                    if (hasOwn.call(built, param))\n                        return;\n                    var all = this.allFields;\n                    if (!hasOwn.call(all, param)) {\n                        throw new Error('' + param);\n                    }\n                    var field = all[param];\n                    var type = field.type;\n                    var value;\n                    if (isArgAvailable) {\n                        value = arg;\n                    } else if (field.defaultFn) {\n                        value = field.defaultFn.call(built);\n                    } else {\n                        var message = 'no value or default function given for field ' + JSON.stringify(param) + ' of ' + this.typeName + '(' + this.buildParams.map(function (name) {\n                            return all[name];\n                        }).join(', ') + ')';\n                        throw new Error(message);\n                    }\n                    if (!type.check(value)) {\n                        throw new Error(shallowStringify(value) + ' does not match field ' + field + ' of type ' + this.typeName);\n                    }\n                    built[param] = value;\n                };\n                const builder = (...args) => {\n                    var argc = args.length;\n                    if (!this.finalized) {\n                        throw new Error('attempting to instantiate unfinalized type ' + this.typeName);\n                    }\n                    var built = Object.create(nodePrototype);\n                    this.buildParams.forEach(function (param, i) {\n                        if (i < argc) {\n                            addParam(built, param, args[i], true);\n                        } else {\n                            addParam(built, param, null, false);\n                        }\n                    });\n                    Object.keys(this.allFields).forEach(function (param) {\n                        addParam(built, param, null, false);\n                    });\n                    if (built.type !== this.typeName) {\n                        throw new Error('');\n                    }\n                    return built;\n                };\n                builder.from = obj => {\n                    if (!this.finalized) {\n                        throw new Error('attempting to instantiate unfinalized type ' + this.typeName);\n                    }\n                    var built = Object.create(nodePrototype);\n                    Object.keys(this.allFields).forEach(function (param) {\n                        if (hasOwn.call(obj, param)) {\n                            addParam(built, param, obj[param], true);\n                        } else {\n                            addParam(built, param, null, false);\n                        }\n                    });\n                    if (built.type !== this.typeName) {\n                        throw new Error('');\n                    }\n                    return built;\n                };\n                Object.defineProperty(builders, getBuilderName(this.typeName), {\n                    enumerable: true,\n                    value: builder\n                });\n                return this;\n            }\n            field(name, type, defaultFn, hidden) {\n                if (this.finalized) {\n                    console.error('Ignoring attempt to redefine field ' + JSON.stringify(name) + ' of finalized type ' + JSON.stringify(this.typeName));\n                    return this;\n                }\n                this.ownFields[name] = new Field(name, Type.from(type), defaultFn, hidden);\n                return this;\n            }\n            finalize() {\n                if (!this.finalized) {\n                    var allFields = this.allFields;\n                    var allSupertypes = this.allSupertypes;\n                    this.baseNames.forEach(name => {\n                        var def = defCache[name];\n                        if (def instanceof Def) {\n                            def.finalize();\n                            extend(allFields, def.allFields);\n                            extend(allSupertypes, def.allSupertypes);\n                        } else {\n                            var message = 'unknown supertype name ' + JSON.stringify(name) + ' for subtype ' + JSON.stringify(this.typeName);\n                            throw new Error(message);\n                        }\n                    });\n                    extend(allFields, this.ownFields);\n                    allSupertypes[this.typeName] = this;\n                    this.fieldNames.length = 0;\n                    for (var fieldName in allFields) {\n                        if (hasOwn.call(allFields, fieldName) && !allFields[fieldName].hidden) {\n                            this.fieldNames.push(fieldName);\n                        }\n                    }\n                    Object.defineProperty(namedTypes, this.typeName, {\n                        enumerable: true,\n                        value: this.type\n                    });\n                    this.finalized = true;\n                    populateSupertypeList(this.typeName, this.supertypeList);\n                    if (this.buildable && this.supertypeList.lastIndexOf('Expression') >= 0) {\n                        wrapExpressionBuilderWithStatement(this.typeName);\n                    }\n                }\n            }\n        }\n        function getSupertypeNames(typeName) {\n            if (!hasOwn.call(defCache, typeName)) {\n                throw new Error('');\n            }\n            var d = defCache[typeName];\n            if (d.finalized !== true) {\n                throw new Error('');\n            }\n            return d.supertypeList.slice(1);\n        }\n        function computeSupertypeLookupTable(candidates) {\n            var table = {};\n            var typeNames = Object.keys(defCache);\n            var typeNameCount = typeNames.length;\n            for (var i = 0; i < typeNameCount; ++i) {\n                var typeName = typeNames[i];\n                var d = defCache[typeName];\n                if (d.finalized !== true) {\n                    throw new Error('' + typeName);\n                }\n                for (var j = 0; j < d.supertypeList.length; ++j) {\n                    var superTypeName = d.supertypeList[j];\n                    if (hasOwn.call(candidates, superTypeName)) {\n                        table[typeName] = superTypeName;\n                        break;\n                    }\n                }\n            }\n            return table;\n        }\n        var builders = Object.create(null);\n        var nodePrototype = {};\n        function defineMethod(name, func) {\n            var old = nodePrototype[name];\n            if (isUndefined.check(func)) {\n                delete nodePrototype[name];\n            } else {\n                isFunction.assert(func);\n                Object.defineProperty(nodePrototype, name, {\n                    enumerable: true,\n                    configurable: true,\n                    value: func\n                });\n            }\n            return old;\n        }\n        function getBuilderName(typeName) {\n            return typeName.replace(/^[A-Z]+/, function (upperCasePrefix) {\n                var len = upperCasePrefix.length;\n                switch (len) {\n                case 0:\n                    return '';\n                case 1:\n                    return upperCasePrefix.toLowerCase();\n                default:\n                    return upperCasePrefix.slice(0, len - 1).toLowerCase() + upperCasePrefix.charAt(len - 1);\n                }\n            });\n        }\n        function getStatementBuilderName(typeName) {\n            typeName = getBuilderName(typeName);\n            return typeName.replace(/(Expression)?$/, 'Statement');\n        }\n        var namedTypes = {};\n        function getFieldNames(object) {\n            var d = defFromValue(object);\n            if (d) {\n                return d.fieldNames.slice(0);\n            }\n            if ('type' in object) {\n                throw new Error('did not recognize object of type ' + JSON.stringify(object.type));\n            }\n            return Object.keys(object);\n        }\n        function getFieldValue(object, fieldName) {\n            var d = defFromValue(object);\n            if (d) {\n                var field = d.allFields[fieldName];\n                if (field) {\n                    return field.getValue(object);\n                }\n            }\n            return object && object[fieldName];\n        }\n        function eachField(object, callback, context) {\n            getFieldNames(object).forEach(function (name) {\n                callback.call(this, name, getFieldValue(object, name));\n            }, context);\n        }\n        function someField(object, callback, context) {\n            return getFieldNames(object).some(function (name) {\n                return callback.call(this, name, getFieldValue(object, name));\n            }, context);\n        }\n        function wrapExpressionBuilderWithStatement(typeName) {\n            var wrapperName = getStatementBuilderName(typeName);\n            if (builders[wrapperName])\n                return;\n            var wrapped = builders[getBuilderName(typeName)];\n            if (!wrapped)\n                return;\n            const builder = function (...args) {\n                return builders.expressionStatement(wrapped.apply(builders, args));\n            };\n            builder.from = function (...args) {\n                return builders.expressionStatement(wrapped.from.apply(builders, args));\n            };\n            builders[wrapperName] = builder;\n        }\n        function populateSupertypeList(typeName, list) {\n            list.length = 0;\n            list.push(typeName);\n            var lastSeen = Object.create(null);\n            for (var pos = 0; pos < list.length; ++pos) {\n                typeName = list[pos];\n                var d = defCache[typeName];\n                if (d.finalized !== true) {\n                    throw new Error('');\n                }\n                if (hasOwn.call(lastSeen, typeName)) {\n                    delete list[lastSeen[typeName]];\n                }\n                lastSeen[typeName] = pos;\n                list.push.apply(list, d.baseNames);\n            }\n            for (var to = 0, from = to, len = list.length; from < len; ++from) {\n                if (hasOwn.call(list, from)) {\n                    list[to++] = list[from];\n                }\n            }\n            list.length = to;\n        }\n        function extend(into, from) {\n            Object.keys(from).forEach(function (name) {\n                into[name] = from[name];\n            });\n            return into;\n        }\n        function finalize() {\n            Object.keys(defCache).forEach(function (name) {\n                defCache[name].finalize();\n            });\n        }\n        return {\n            Type,\n            builtInTypes,\n            getSupertypeNames,\n            computeSupertypeLookupTable,\n            builders,\n            defineMethod,\n            getBuilderName,\n            getStatementBuilderName,\n            namedTypes,\n            getFieldNames,\n            getFieldValue,\n            eachField,\n            someField,\n            finalize,\n        };\n    };\n    \n    return typesPlugin;\n});"]}