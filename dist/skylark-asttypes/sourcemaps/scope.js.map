{"version":3,"sources":["scope.js"],"names":["define","typesPlugin","hasOwn","Object","prototype","hasOwnProperty","fork","Scope","path","parentScope","this","Error","depth","TypeParameterScopeType","check","value","ScopeType","assert","defineProperties","node","isGlobal","enumerable","parent","bindings","types","use","Type","namedTypes","Node","Expression","isArray","builtInTypes","array","b","builders","or","Program","Function","CatchClause","ClassDeclaration","ClassExpression","InterfaceDeclaration","TSInterfaceDeclaration","TypeAlias","TSTypeAliasDeclaration","FlowOrTSTypeParameterType","TypeParameter","TSTypeParameter","Sp","isEstablishedBy","recursiveScanScope","scopeTypes","FunctionExpression","id","addPattern","get","each","childPath","recursiveScanChild","paramPath","addTypePattern","VariableDeclarator","type","local","name","eachField","child","Array","length","hadBinding","FunctionDeclaration","Identifier","param","catchParamName","call","patternPath","pattern","Pattern","push","AssignmentPattern","ObjectPattern","propertyPath","property","Property","ObjectProperty","SpreadProperty","ArrayPattern","elementPath","element","SpreadElement","PropertyPattern","SpreadElementPattern","RestElement","SpreadPropertyPattern","didScan","declares","scan","declaresType","declareTemporary","prefix","test","toString","index","identifier","injectTemporary","init","bodyPath","BlockStatement","unshift","variableDeclaration","variableDeclarator","force","scanScope","params","parameter","parameterPath","getBindings","getTypes","lookup","scope","lookupType","getGlobalScope"],"mappings":"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","file":"../scope.js","sourcesContent":["define(['./types'], function (typesPlugin) {\n    'use strict';\n    var hasOwn = Object.prototype.hasOwnProperty;\n    return function scopePlugin(fork) {\n        var types = fork.use(typesPlugin);\n        var Type = types.Type;\n        var namedTypes = types.namedTypes;\n        var Node = namedTypes.Node;\n        var Expression = namedTypes.Expression;\n        var isArray = types.builtInTypes.array;\n        var b = types.builders;\n        const Scope = function Scope(path, parentScope) {\n            if (!(this instanceof Scope)) {\n                throw new Error(\"Scope constructor cannot be invoked without 'new'\");\n            }\n            if (!TypeParameterScopeType.check(path.value)) {\n                ScopeType.assert(path.value);\n            }\n            var depth;\n            if (parentScope) {\n                if (!(parentScope instanceof Scope)) {\n                    throw new Error('');\n                }\n                depth = parentScope.depth + 1;\n            } else {\n                parentScope = null;\n                depth = 0;\n            }\n            Object.defineProperties(this, {\n                path: { value: path },\n                node: { value: path.value },\n                isGlobal: {\n                    value: !parentScope,\n                    enumerable: true\n                },\n                depth: { value: depth },\n                parent: { value: parentScope },\n                bindings: { value: {} },\n                types: { value: {} }\n            });\n        };\n        var ScopeType = Type.or(namedTypes.Program, namedTypes.Function, namedTypes.CatchClause);\n        var TypeParameterScopeType = Type.or(namedTypes.Function, namedTypes.ClassDeclaration, namedTypes.ClassExpression, namedTypes.InterfaceDeclaration, namedTypes.TSInterfaceDeclaration, namedTypes.TypeAlias, namedTypes.TSTypeAliasDeclaration);\n        var FlowOrTSTypeParameterType = Type.or(namedTypes.TypeParameter, namedTypes.TSTypeParameter);\n        Scope.isEstablishedBy = function (node) {\n            return ScopeType.check(node) || TypeParameterScopeType.check(node);\n        };\n        var Sp = Scope.prototype;\n        Sp.didScan = false;\n        Sp.declares = function (name) {\n            this.scan();\n            return hasOwn.call(this.bindings, name);\n        };\n        Sp.declaresType = function (name) {\n            this.scan();\n            return hasOwn.call(this.types, name);\n        };\n        Sp.declareTemporary = function (prefix) {\n            if (prefix) {\n                if (!/^[a-z$_]/i.test(prefix)) {\n                    throw new Error('');\n                }\n            } else {\n                prefix = 't$';\n            }\n            prefix += this.depth.toString(36) + '$';\n            this.scan();\n            var index = 0;\n            while (this.declares(prefix + index)) {\n                ++index;\n            }\n            var name = prefix + index;\n            return this.bindings[name] = types.builders.identifier(name);\n        };\n        Sp.injectTemporary = function (identifier, init) {\n            identifier || (identifier = this.declareTemporary());\n            var bodyPath = this.path.get('body');\n            if (namedTypes.BlockStatement.check(bodyPath.value)) {\n                bodyPath = bodyPath.get('body');\n            }\n            bodyPath.unshift(b.variableDeclaration('var', [b.variableDeclarator(identifier, init || null)]));\n            return identifier;\n        };\n        Sp.scan = function (force) {\n            if (force || !this.didScan) {\n                for (var name in this.bindings) {\n                    delete this.bindings[name];\n                }\n                for (var name in this.types) {\n                    delete this.types[name];\n                }\n                scanScope(this.path, this.bindings, this.types);\n                this.didScan = true;\n            }\n        };\n        Sp.getBindings = function () {\n            this.scan();\n            return this.bindings;\n        };\n        Sp.getTypes = function () {\n            this.scan();\n            return this.types;\n        };\n        function scanScope(path, bindings, scopeTypes) {\n            var node = path.value;\n            if (TypeParameterScopeType.check(node)) {\n                const params = path.get('typeParameters', 'params');\n                if (isArray.check(params.value)) {\n                    params.each(childPath => {\n                        addTypeParameter(childPath, scopeTypes);\n                    });\n                }\n            }\n            if (ScopeType.check(node)) {\n                if (namedTypes.CatchClause.check(node)) {\n                    addPattern(path.get('param'), bindings);\n                } else {\n                    recursiveScanScope(path, bindings, scopeTypes);\n                }\n            }\n        }\n        function recursiveScanScope(path, bindings, scopeTypes) {\n            var node = path.value;\n            if (path.parent && namedTypes.FunctionExpression.check(path.parent.node) && path.parent.node.id) {\n                addPattern(path.parent.get('id'), bindings);\n            }\n            if (!node) {\n            } else if (isArray.check(node)) {\n                path.each(childPath => {\n                    recursiveScanChild(childPath, bindings, scopeTypes);\n                });\n            } else if (namedTypes.Function.check(node)) {\n                path.get('params').each(paramPath => {\n                    addPattern(paramPath, bindings);\n                });\n                recursiveScanChild(path.get('body'), bindings, scopeTypes);\n                recursiveScanScope(path.get('typeParameters'), bindings, scopeTypes);\n            } else if (namedTypes.TypeAlias && namedTypes.TypeAlias.check(node) || namedTypes.InterfaceDeclaration && namedTypes.InterfaceDeclaration.check(node) || namedTypes.TSTypeAliasDeclaration && namedTypes.TSTypeAliasDeclaration.check(node) || namedTypes.TSInterfaceDeclaration && namedTypes.TSInterfaceDeclaration.check(node)) {\n                addTypePattern(path.get('id'), scopeTypes);\n            } else if (namedTypes.VariableDeclarator.check(node)) {\n                addPattern(path.get('id'), bindings);\n                recursiveScanChild(path.get('init'), bindings, scopeTypes);\n            } else if (node.type === 'ImportSpecifier' || node.type === 'ImportNamespaceSpecifier' || node.type === 'ImportDefaultSpecifier') {\n                addPattern(path.get(node.local ? 'local' : node.name ? 'name' : 'id'), bindings);\n            } else if (Node.check(node) && !Expression.check(node)) {\n                types.eachField(node, function (name, child) {\n                    var childPath = path.get(name);\n                    if (!pathHasValue(childPath, child)) {\n                        throw new Error('');\n                    }\n                    recursiveScanChild(childPath, bindings, scopeTypes);\n                });\n            }\n        }\n        function pathHasValue(path, value) {\n            if (path.value === value) {\n                return true;\n            }\n            if (Array.isArray(path.value) && path.value.length === 0 && Array.isArray(value) && value.length === 0) {\n                return true;\n            }\n            return false;\n        }\n        function recursiveScanChild(path, bindings, scopeTypes) {\n            var node = path.value;\n            if (!node || Expression.check(node)) {\n            } else if (namedTypes.FunctionDeclaration.check(node) && node.id !== null) {\n                addPattern(path.get('id'), bindings);\n            } else if (namedTypes.ClassDeclaration && namedTypes.ClassDeclaration.check(node) && node.id !== null) {\n                addPattern(path.get('id'), bindings);\n                recursiveScanScope(path.get('typeParameters'), bindings, scopeTypes);\n            } else if (namedTypes.InterfaceDeclaration && namedTypes.InterfaceDeclaration.check(node) || namedTypes.TSInterfaceDeclaration && namedTypes.TSInterfaceDeclaration.check(node)) {\n                addTypePattern(path.get('id'), scopeTypes);\n            } else if (ScopeType.check(node)) {\n                if (namedTypes.CatchClause.check(node) && namedTypes.Identifier.check(node.param)) {\n                    var catchParamName = node.param.name;\n                    var hadBinding = hasOwn.call(bindings, catchParamName);\n                    recursiveScanScope(path.get('body'), bindings, scopeTypes);\n                    if (!hadBinding) {\n                        delete bindings[catchParamName];\n                    }\n                }\n            } else {\n                recursiveScanScope(path, bindings, scopeTypes);\n            }\n        }\n        function addPattern(patternPath, bindings) {\n            var pattern = patternPath.value;\n            namedTypes.Pattern.assert(pattern);\n            if (namedTypes.Identifier.check(pattern)) {\n                if (hasOwn.call(bindings, pattern.name)) {\n                    bindings[pattern.name].push(patternPath);\n                } else {\n                    bindings[pattern.name] = [patternPath];\n                }\n            } else if (namedTypes.AssignmentPattern && namedTypes.AssignmentPattern.check(pattern)) {\n                addPattern(patternPath.get('left'), bindings);\n            } else if (namedTypes.ObjectPattern && namedTypes.ObjectPattern.check(pattern)) {\n                patternPath.get('properties').each(function (propertyPath) {\n                    var property = propertyPath.value;\n                    if (namedTypes.Pattern.check(property)) {\n                        addPattern(propertyPath, bindings);\n                    } else if (namedTypes.Property.check(property) || namedTypes.ObjectProperty && namedTypes.ObjectProperty.check(property)) {\n                        addPattern(propertyPath.get('value'), bindings);\n                    } else if (namedTypes.SpreadProperty && namedTypes.SpreadProperty.check(property)) {\n                        addPattern(propertyPath.get('argument'), bindings);\n                    }\n                });\n            } else if (namedTypes.ArrayPattern && namedTypes.ArrayPattern.check(pattern)) {\n                patternPath.get('elements').each(function (elementPath) {\n                    var element = elementPath.value;\n                    if (namedTypes.Pattern.check(element)) {\n                        addPattern(elementPath, bindings);\n                    } else if (namedTypes.SpreadElement && namedTypes.SpreadElement.check(element)) {\n                        addPattern(elementPath.get('argument'), bindings);\n                    }\n                });\n            } else if (namedTypes.PropertyPattern && namedTypes.PropertyPattern.check(pattern)) {\n                addPattern(patternPath.get('pattern'), bindings);\n            } else if (namedTypes.SpreadElementPattern && namedTypes.SpreadElementPattern.check(pattern) || namedTypes.RestElement && namedTypes.RestElement.check(pattern) || namedTypes.SpreadPropertyPattern && namedTypes.SpreadPropertyPattern.check(pattern)) {\n                addPattern(patternPath.get('argument'), bindings);\n            }\n        }\n        function addTypePattern(patternPath, types) {\n            var pattern = patternPath.value;\n            namedTypes.Pattern.assert(pattern);\n            if (namedTypes.Identifier.check(pattern)) {\n                if (hasOwn.call(types, pattern.name)) {\n                    types[pattern.name].push(patternPath);\n                } else {\n                    types[pattern.name] = [patternPath];\n                }\n            }\n        }\n        function addTypeParameter(parameterPath, types) {\n            var parameter = parameterPath.value;\n            FlowOrTSTypeParameterType.assert(parameter);\n            if (hasOwn.call(types, parameter.name)) {\n                types[parameter.name].push(parameterPath);\n            } else {\n                types[parameter.name] = [parameterPath];\n            }\n        }\n        Sp.lookup = function (name) {\n            for (var scope = this; scope; scope = scope.parent)\n                if (scope.declares(name))\n                    break;\n            return scope;\n        };\n        Sp.lookupType = function (name) {\n            for (var scope = this; scope; scope = scope.parent)\n                if (scope.declaresType(name))\n                    break;\n            return scope;\n        };\n        Sp.getGlobalScope = function () {\n            var scope = this;\n            while (!scope.isGlobal)\n                scope = scope.parent;\n            return scope;\n        };\n        return Scope;\n    };\n});"]}