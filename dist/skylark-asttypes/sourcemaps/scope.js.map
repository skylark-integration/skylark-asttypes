{"version":3,"sources":["scope.js"],"names":["define","typesPlugin","hasOwn","Object","prototype","hasOwnProperty","fork","types","use","Type","namedTypes","Node","Expression","isArray","builtInTypes","array","b","builders","Scope","path","parentScope","this","Error","depth","TypeParameterScopeType","check","value","ScopeType","assert","defineProperties","node","isGlobal","enumerable","parent","bindings","or","Program","Function","CatchClause","ClassDeclaration","ClassExpression","InterfaceDeclaration","TSInterfaceDeclaration","TypeAlias","TSTypeAliasDeclaration","FlowOrTSTypeParameterType","TypeParameter","TSTypeParameter","isEstablishedBy","Sp","recursiveScanScope","scopeTypes","FunctionExpression","id","addPattern","get","each","childPath","recursiveScanChild","paramPath","addTypePattern","VariableDeclarator","type","local","name","eachField","child","Array","length","pathHasValue","FunctionDeclaration","Identifier","param","catchParamName","hadBinding","call","patternPath","pattern","Pattern","push","AssignmentPattern","ObjectPattern","propertyPath","property","Property","ObjectProperty","SpreadProperty","ArrayPattern","elementPath","element","SpreadElement","PropertyPattern","SpreadElementPattern","RestElement","SpreadPropertyPattern","didScan","declares","scan","declaresType","declareTemporary","prefix","test","toString","index","identifier","injectTemporary","init","bodyPath","BlockStatement","unshift","variableDeclaration","variableDeclarator","force","params","parameter","parameterPath","scanScope","getBindings","getTypes","lookup","scope","lookupType","getGlobalScope"],"mappings":"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","file":"../scope.js","sourcesContent":["define(['./types'], function (typesPlugin) {\n    'use strict';\n    var hasOwn = Object.prototype.hasOwnProperty;\n    return function scopePlugin(fork) {\n        var types = fork.use(typesPlugin);\n        var Type = types.Type;\n        var namedTypes = types.namedTypes;\n        var Node = namedTypes.Node;\n        var Expression = namedTypes.Expression;\n        var isArray = types.builtInTypes.array;\n        var b = types.builders;\n        const Scope = function Scope(path, parentScope) {\n            if (!(this instanceof Scope)) {\n                throw new Error(\"Scope constructor cannot be invoked without 'new'\");\n            }\n            if (!TypeParameterScopeType.check(path.value)) {\n                ScopeType.assert(path.value);\n            }\n            var depth;\n            if (parentScope) {\n                if (!(parentScope instanceof Scope)) {\n                    throw new Error('');\n                }\n                depth = parentScope.depth + 1;\n            } else {\n                parentScope = null;\n                depth = 0;\n            }\n            Object.defineProperties(this, {\n                path: { value: path },\n                node: { value: path.value },\n                isGlobal: {\n                    value: !parentScope,\n                    enumerable: true\n                },\n                depth: { value: depth },\n                parent: { value: parentScope },\n                bindings: { value: {} },\n                types: { value: {} }\n            });\n        };\n        var ScopeType = Type.or(namedTypes.Program, namedTypes.Function, namedTypes.CatchClause);\n        var TypeParameterScopeType = Type.or(namedTypes.Function, namedTypes.ClassDeclaration, namedTypes.ClassExpression, namedTypes.InterfaceDeclaration, namedTypes.TSInterfaceDeclaration, namedTypes.TypeAlias, namedTypes.TSTypeAliasDeclaration);\n        var FlowOrTSTypeParameterType = Type.or(namedTypes.TypeParameter, namedTypes.TSTypeParameter);\n        Scope.isEstablishedBy = function (node) {\n            return ScopeType.check(node) || TypeParameterScopeType.check(node);\n        };\n        var Sp = Scope.prototype;\n        Sp.didScan = false;\n        Sp.declares = function (name) {\n            this.scan();\n            return hasOwn.call(this.bindings, name);\n        };\n        Sp.declaresType = function (name) {\n            this.scan();\n            return hasOwn.call(this.types, name);\n        };\n        Sp.declareTemporary = function (prefix) {\n            if (prefix) {\n                if (!/^[a-z$_]/i.test(prefix)) {\n                    throw new Error('');\n                }\n            } else {\n                prefix = 't$';\n            }\n            prefix += this.depth.toString(36) + '$';\n            this.scan();\n            var index = 0;\n            while (this.declares(prefix + index)) {\n                ++index;\n            }\n            var name = prefix + index;\n            return this.bindings[name] = types.builders.identifier(name);\n        };\n        Sp.injectTemporary = function (identifier, init) {\n            identifier || (identifier = this.declareTemporary());\n            var bodyPath = this.path.get('body');\n            if (namedTypes.BlockStatement.check(bodyPath.value)) {\n                bodyPath = bodyPath.get('body');\n            }\n            bodyPath.unshift(b.variableDeclaration('var', [b.variableDeclarator(identifier, init || null)]));\n            return identifier;\n        };\n        Sp.scan = function (force) {\n            if (force || !this.didScan) {\n                for (var name in this.bindings) {\n                    delete this.bindings[name];\n                }\n                for (var name in this.types) {\n                    delete this.types[name];\n                }\n                scanScope(this.path, this.bindings, this.types);\n                this.didScan = true;\n            }\n        };\n        Sp.getBindings = function () {\n            this.scan();\n            return this.bindings;\n        };\n        Sp.getTypes = function () {\n            this.scan();\n            return this.types;\n        };\n        function scanScope(path, bindings, scopeTypes) {\n            var node = path.value;\n            if (TypeParameterScopeType.check(node)) {\n                const params = path.get('typeParameters', 'params');\n                if (isArray.check(params.value)) {\n                    params.each(childPath => {\n                        addTypeParameter(childPath, scopeTypes);\n                    });\n                }\n            }\n            if (ScopeType.check(node)) {\n                if (namedTypes.CatchClause.check(node)) {\n                    addPattern(path.get('param'), bindings);\n                } else {\n                    recursiveScanScope(path, bindings, scopeTypes);\n                }\n            }\n        }\n        function recursiveScanScope(path, bindings, scopeTypes) {\n            var node = path.value;\n            if (path.parent && namedTypes.FunctionExpression.check(path.parent.node) && path.parent.node.id) {\n                addPattern(path.parent.get('id'), bindings);\n            }\n            if (!node) {\n            } else if (isArray.check(node)) {\n                path.each(childPath => {\n                    recursiveScanChild(childPath, bindings, scopeTypes);\n                });\n            } else if (namedTypes.Function.check(node)) {\n                path.get('params').each(paramPath => {\n                    addPattern(paramPath, bindings);\n                });\n                recursiveScanChild(path.get('body'), bindings, scopeTypes);\n                recursiveScanScope(path.get('typeParameters'), bindings, scopeTypes);\n            } else if (namedTypes.TypeAlias && namedTypes.TypeAlias.check(node) || namedTypes.InterfaceDeclaration && namedTypes.InterfaceDeclaration.check(node) || namedTypes.TSTypeAliasDeclaration && namedTypes.TSTypeAliasDeclaration.check(node) || namedTypes.TSInterfaceDeclaration && namedTypes.TSInterfaceDeclaration.check(node)) {\n                addTypePattern(path.get('id'), scopeTypes);\n            } else if (namedTypes.VariableDeclarator.check(node)) {\n                addPattern(path.get('id'), bindings);\n                recursiveScanChild(path.get('init'), bindings, scopeTypes);\n            } else if (node.type === 'ImportSpecifier' || node.type === 'ImportNamespaceSpecifier' || node.type === 'ImportDefaultSpecifier') {\n                addPattern(path.get(node.local ? 'local' : node.name ? 'name' : 'id'), bindings);\n            } else if (Node.check(node) && !Expression.check(node)) {\n                types.eachField(node, function (name, child) {\n                    var childPath = path.get(name);\n                    if (!pathHasValue(childPath, child)) {\n                        throw new Error('');\n                    }\n                    recursiveScanChild(childPath, bindings, scopeTypes);\n                });\n            }\n        }\n        function pathHasValue(path, value) {\n            if (path.value === value) {\n                return true;\n            }\n            if (Array.isArray(path.value) && path.value.length === 0 && Array.isArray(value) && value.length === 0) {\n                return true;\n            }\n            return false;\n        }\n        function recursiveScanChild(path, bindings, scopeTypes) {\n            var node = path.value;\n            if (!node || Expression.check(node)) {\n            } else if (namedTypes.FunctionDeclaration.check(node) && node.id !== null) {\n                addPattern(path.get('id'), bindings);\n            } else if (namedTypes.ClassDeclaration && namedTypes.ClassDeclaration.check(node) && node.id !== null) {\n                addPattern(path.get('id'), bindings);\n                recursiveScanScope(path.get('typeParameters'), bindings, scopeTypes);\n            } else if (namedTypes.InterfaceDeclaration && namedTypes.InterfaceDeclaration.check(node) || namedTypes.TSInterfaceDeclaration && namedTypes.TSInterfaceDeclaration.check(node)) {\n                addTypePattern(path.get('id'), scopeTypes);\n            } else if (ScopeType.check(node)) {\n                if (namedTypes.CatchClause.check(node) && namedTypes.Identifier.check(node.param)) {\n                    var catchParamName = node.param.name;\n                    var hadBinding = hasOwn.call(bindings, catchParamName);\n                    recursiveScanScope(path.get('body'), bindings, scopeTypes);\n                    if (!hadBinding) {\n                        delete bindings[catchParamName];\n                    }\n                }\n            } else {\n                recursiveScanScope(path, bindings, scopeTypes);\n            }\n        }\n        function addPattern(patternPath, bindings) {\n            var pattern = patternPath.value;\n            namedTypes.Pattern.assert(pattern);\n            if (namedTypes.Identifier.check(pattern)) {\n                if (hasOwn.call(bindings, pattern.name)) {\n                    bindings[pattern.name].push(patternPath);\n                } else {\n                    bindings[pattern.name] = [patternPath];\n                }\n            } else if (namedTypes.AssignmentPattern && namedTypes.AssignmentPattern.check(pattern)) {\n                addPattern(patternPath.get('left'), bindings);\n            } else if (namedTypes.ObjectPattern && namedTypes.ObjectPattern.check(pattern)) {\n                patternPath.get('properties').each(function (propertyPath) {\n                    var property = propertyPath.value;\n                    if (namedTypes.Pattern.check(property)) {\n                        addPattern(propertyPath, bindings);\n                    } else if (namedTypes.Property.check(property) || namedTypes.ObjectProperty && namedTypes.ObjectProperty.check(property)) {\n                        addPattern(propertyPath.get('value'), bindings);\n                    } else if (namedTypes.SpreadProperty && namedTypes.SpreadProperty.check(property)) {\n                        addPattern(propertyPath.get('argument'), bindings);\n                    }\n                });\n            } else if (namedTypes.ArrayPattern && namedTypes.ArrayPattern.check(pattern)) {\n                patternPath.get('elements').each(function (elementPath) {\n                    var element = elementPath.value;\n                    if (namedTypes.Pattern.check(element)) {\n                        addPattern(elementPath, bindings);\n                    } else if (namedTypes.SpreadElement && namedTypes.SpreadElement.check(element)) {\n                        addPattern(elementPath.get('argument'), bindings);\n                    }\n                });\n            } else if (namedTypes.PropertyPattern && namedTypes.PropertyPattern.check(pattern)) {\n                addPattern(patternPath.get('pattern'), bindings);\n            } else if (namedTypes.SpreadElementPattern && namedTypes.SpreadElementPattern.check(pattern) || namedTypes.RestElement && namedTypes.RestElement.check(pattern) || namedTypes.SpreadPropertyPattern && namedTypes.SpreadPropertyPattern.check(pattern)) {\n                addPattern(patternPath.get('argument'), bindings);\n            }\n        }\n        function addTypePattern(patternPath, types) {\n            var pattern = patternPath.value;\n            namedTypes.Pattern.assert(pattern);\n            if (namedTypes.Identifier.check(pattern)) {\n                if (hasOwn.call(types, pattern.name)) {\n                    types[pattern.name].push(patternPath);\n                } else {\n                    types[pattern.name] = [patternPath];\n                }\n            }\n        }\n        function addTypeParameter(parameterPath, types) {\n            var parameter = parameterPath.value;\n            FlowOrTSTypeParameterType.assert(parameter);\n            if (hasOwn.call(types, parameter.name)) {\n                types[parameter.name].push(parameterPath);\n            } else {\n                types[parameter.name] = [parameterPath];\n            }\n        }\n        Sp.lookup = function (name) {\n            for (var scope = this; scope; scope = scope.parent)\n                if (scope.declares(name))\n                    break;\n            return scope;\n        };\n        Sp.lookupType = function (name) {\n            for (var scope = this; scope; scope = scope.parent)\n                if (scope.declaresType(name))\n                    break;\n            return scope;\n        };\n        Sp.getGlobalScope = function () {\n            var scope = this;\n            while (!scope.isGlobal)\n                scope = scope.parent;\n            return scope;\n        };\n        return Scope;\n    };\n});"]}