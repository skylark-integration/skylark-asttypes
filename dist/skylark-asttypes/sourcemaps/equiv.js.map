{"version":3,"sources":["equiv.js"],"names":["define","typesPlugin","fork","types","use","getFieldNames","getFieldValue","isArray","builtInTypes","array","isObject","object","isDate","Date","isRegExp","RegExp","hasOwn","Object","prototype","hasOwnProperty","astNodesAreEquivalent","a","b","problemPath","check","length","areEquivalent","subscriptForProperty","property","test","JSON","stringify","arraysAreEquivalent","aLength","assert","push","i","problemPathTail","pop","Error","objectsAreEquivalent","type","aNames","aNameCount","bNames","bNameCount","name","aChild","bChild","seenNames","create","call","source","global","multiline","ignoreCase","map","join"],"mappings":"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","file":"../equiv.js","sourcesContent":["define(['./types'], function (typesPlugin) {\n    'use strict';\n    return function (fork) {\n        var types = fork.use(typesPlugin);\n        var getFieldNames = types.getFieldNames;\n        var getFieldValue = types.getFieldValue;\n        var isArray = types.builtInTypes.array;\n        var isObject = types.builtInTypes.object;\n        var isDate = types.builtInTypes.Date;\n        var isRegExp = types.builtInTypes.RegExp;\n        var hasOwn = Object.prototype.hasOwnProperty;\n        function astNodesAreEquivalent(a, b, problemPath) {\n            if (isArray.check(problemPath)) {\n                problemPath.length = 0;\n            } else {\n                problemPath = null;\n            }\n            return areEquivalent(a, b, problemPath);\n        }\n        astNodesAreEquivalent.assert = function (a, b) {\n            var problemPath = [];\n            if (!astNodesAreEquivalent(a, b, problemPath)) {\n                if (problemPath.length === 0) {\n                    if (a !== b) {\n                        throw new Error('Nodes must be equal');\n                    }\n                } else {\n                    throw new Error('Nodes differ in the following path: ' + problemPath.map(subscriptForProperty).join(''));\n                }\n            }\n        };\n        function subscriptForProperty(property) {\n            if (/[_$a-z][_$a-z0-9]*/i.test(property)) {\n                return '.' + property;\n            }\n            return '[' + JSON.stringify(property) + ']';\n        }\n        function areEquivalent(a, b, problemPath) {\n            if (a === b) {\n                return true;\n            }\n            if (isArray.check(a)) {\n                return arraysAreEquivalent(a, b, problemPath);\n            }\n            if (isObject.check(a)) {\n                return objectsAreEquivalent(a, b, problemPath);\n            }\n            if (isDate.check(a)) {\n                return isDate.check(b) && +a === +b;\n            }\n            if (isRegExp.check(a)) {\n                return isRegExp.check(b) && (a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.ignoreCase === b.ignoreCase);\n            }\n            return a == b;\n        }\n        function arraysAreEquivalent(a, b, problemPath) {\n            isArray.assert(a);\n            var aLength = a.length;\n            if (!isArray.check(b) || b.length !== aLength) {\n                if (problemPath) {\n                    problemPath.push('length');\n                }\n                return false;\n            }\n            for (var i = 0; i < aLength; ++i) {\n                if (problemPath) {\n                    problemPath.push(i);\n                }\n                if (i in a !== i in b) {\n                    return false;\n                }\n                if (!areEquivalent(a[i], b[i], problemPath)) {\n                    return false;\n                }\n                if (problemPath) {\n                    var problemPathTail = problemPath.pop();\n                    if (problemPathTail !== i) {\n                        throw new Error('' + problemPathTail);\n                    }\n                }\n            }\n            return true;\n        }\n        function objectsAreEquivalent(a, b, problemPath) {\n            isObject.assert(a);\n            if (!isObject.check(b)) {\n                return false;\n            }\n            if (a.type !== b.type) {\n                if (problemPath) {\n                    problemPath.push('type');\n                }\n                return false;\n            }\n            var aNames = getFieldNames(a);\n            var aNameCount = aNames.length;\n            var bNames = getFieldNames(b);\n            var bNameCount = bNames.length;\n            if (aNameCount === bNameCount) {\n                for (var i = 0; i < aNameCount; ++i) {\n                    var name = aNames[i];\n                    var aChild = getFieldValue(a, name);\n                    var bChild = getFieldValue(b, name);\n                    if (problemPath) {\n                        problemPath.push(name);\n                    }\n                    if (!areEquivalent(aChild, bChild, problemPath)) {\n                        return false;\n                    }\n                    if (problemPath) {\n                        var problemPathTail = problemPath.pop();\n                        if (problemPathTail !== name) {\n                            throw new Error('' + problemPathTail);\n                        }\n                    }\n                }\n                return true;\n            }\n            if (!problemPath) {\n                return false;\n            }\n            var seenNames = Object.create(null);\n            for (i = 0; i < aNameCount; ++i) {\n                seenNames[aNames[i]] = true;\n            }\n            for (i = 0; i < bNameCount; ++i) {\n                name = bNames[i];\n                if (!hasOwn.call(seenNames, name)) {\n                    problemPath.push(name);\n                    return false;\n                }\n                delete seenNames[name];\n            }\n            for (name in seenNames) {\n                problemPath.push(name);\n                break;\n            }\n            return false;\n        }\n        return astNodesAreEquivalent;\n    };\n});"]}