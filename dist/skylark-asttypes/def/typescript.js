/**
 * skylark-asttypes - A version of asttypes that ported to running on skylarkjs.
 * @author Hudaokeji Co.,Ltd
 * @version v0.9.0
 * @link www.skylarkjs.org
 * @license MIT
 */
define(["./babel-core","./type-annotations","../types","../shared"],function(s,p,d,T){"use strict";return function(e){e.use(s),e.use(p);var a=e.use(d),i=a.namedTypes,t=a.Type.def,n=a.Type.or,e=e.use(T).defaults,a=a.Type.from(function(e,a){return!(!i.StringLiteral||!i.StringLiteral.check(e,a))||!(!i.Literal||!i.Literal.check(e,a)||"string"!=typeof e.value)},"StringLiteral"),l=(t("TSType").bases("Node"),n(t("Identifier"),t("TSQualifiedName"))),o=(t("TSTypeReference").bases("TSType","TSHasOptionalTypeParameterInstantiation").build("typeName","typeParameters").field("typeName",l),t("TSHasOptionalTypeParameterInstantiation").field("typeParameters",n(t("TSTypeParameterInstantiation"),null),e.null),t("TSHasOptionalTypeParameters").field("typeParameters",n(t("TSTypeParameterDeclaration"),null,void 0),e.null),t("TSHasOptionalTypeAnnotation").field("typeAnnotation",n(t("TSTypeAnnotation"),null),e.null),t("TSQualifiedName").bases("Node").build("left","right").field("left",l).field("right",l),t("TSAsExpression").bases("Expression","Pattern").build("expression","typeAnnotation").field("expression",t("Expression")).field("typeAnnotation",t("TSType")).field("extra",n({parenthesized:Boolean},null),e.null),t("TSTypeCastExpression").bases("Expression").build("expression","typeAnnotation").field("expression",t("Expression")).field("typeAnnotation",t("TSType")),t("TSSatisfiesExpression").bases("Expression","Pattern").build("expression","typeAnnotation").field("expression",t("Expression")).field("typeAnnotation",t("TSType")),t("TSNonNullExpression").bases("Expression","Pattern").build("expression").field("expression",t("Expression")),["TSAnyKeyword","TSBigIntKeyword","TSBooleanKeyword","TSNeverKeyword","TSNullKeyword","TSNumberKeyword","TSObjectKeyword","TSStringKeyword","TSSymbolKeyword","TSUndefinedKeyword","TSUnknownKeyword","TSVoidKeyword","TSIntrinsicKeyword","TSThisType"].forEach(e=>{t(e).bases("TSType").build()}),t("TSArrayType").bases("TSType").build("elementType").field("elementType",t("TSType")),t("TSLiteralType").bases("TSType").build("literal").field("literal",n(t("NumericLiteral"),t("StringLiteral"),t("BooleanLiteral"),t("TemplateLiteral"),t("UnaryExpression"),t("BigIntLiteral"))),t("TemplateLiteral").field("expressions",n([t("Expression")],[t("TSType")])),["TSUnionType","TSIntersectionType"].forEach(e=>{t(e).bases("TSType").build("types").field("types",[t("TSType")])}),t("TSConditionalType").bases("TSType").build("checkType","extendsType","trueType","falseType").field("checkType",t("TSType")).field("extendsType",t("TSType")).field("trueType",t("TSType")).field("falseType",t("TSType")),t("TSInferType").bases("TSType").build("typeParameter").field("typeParameter",t("TSTypeParameter")),t("TSParenthesizedType").bases("TSType").build("typeAnnotation").field("typeAnnotation",t("TSType")),[n(t("Identifier"),t("RestElement"),t("ArrayPattern"),t("ObjectPattern"))]),r=(["TSFunctionType","TSConstructorType"].forEach(e=>{t(e).bases("TSType","TSHasOptionalTypeParameters","TSHasOptionalTypeAnnotation").build("parameters").field("parameters",o)}),t("TSDeclareFunction").bases("Declaration","TSHasOptionalTypeParameters").build("id","params","returnType").field("declare",Boolean,e.false).field("async",Boolean,e.false).field("generator",Boolean,e.false).field("id",n(t("Identifier"),null),e.null).field("params",[t("Pattern")]).field("returnType",n(t("TSTypeAnnotation"),t("Noop"),null),e.null),t("TSDeclareMethod").bases("Declaration","TSHasOptionalTypeParameters").build("key","params","returnType").field("async",Boolean,e.false).field("generator",Boolean,e.false).field("params",[t("Pattern")]).field("abstract",Boolean,e.false).field("accessibility",n("public","private","protected",void 0),e[void 0]).field("static",Boolean,e.false).field("computed",Boolean,e.false).field("optional",Boolean,e.false).field("key",n(t("Identifier"),t("StringLiteral"),t("NumericLiteral"),t("Expression"))).field("kind",n("get","set","method","constructor"),function(){return"method"}).field("access",n("public","private","protected",void 0),e[void 0]).field("decorators",n([t("Decorator")],null),e.null).field("returnType",n(t("TSTypeAnnotation"),t("Noop"),null),e.null),t("TSMappedType").bases("TSType").build("typeParameter","typeAnnotation").field("readonly",n(Boolean,"+","-"),e.false).field("typeParameter",t("TSTypeParameter")).field("optional",n(Boolean,"+","-"),e.false).field("typeAnnotation",n(t("TSType"),null),e.null),t("TSTupleType").bases("TSType").build("elementTypes").field("elementTypes",[n(t("TSType"),t("TSNamedTupleMember"))]),t("TSNamedTupleMember").bases("TSType").build("label","elementType","optional").field("label",t("Identifier")).field("optional",Boolean,e.false).field("elementType",t("TSType")),t("TSRestType").bases("TSType").build("typeAnnotation").field("typeAnnotation",t("TSType")),t("TSOptionalType").bases("TSType").build("typeAnnotation").field("typeAnnotation",t("TSType")),t("TSIndexedAccessType").bases("TSType").build("objectType","indexType").field("objectType",t("TSType")).field("indexType",t("TSType")),t("TSTypeOperator").bases("TSType").build("operator").field("operator",String).field("typeAnnotation",t("TSType")),t("TSTypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation",n(t("TSType"),t("TSTypeAnnotation"))),t("TSIndexSignature").bases("Declaration","TSHasOptionalTypeAnnotation").build("parameters","typeAnnotation").field("parameters",[t("Identifier")]).field("readonly",Boolean,e.false),t("TSPropertySignature").bases("Declaration","TSHasOptionalTypeAnnotation").build("key","typeAnnotation","optional").field("key",t("Expression")).field("computed",Boolean,e.false).field("readonly",Boolean,e.false).field("optional",Boolean,e.false).field("initializer",n(t("Expression"),null),e.null),t("TSMethodSignature").bases("Declaration","TSHasOptionalTypeParameters","TSHasOptionalTypeAnnotation").build("key","parameters","typeAnnotation").field("key",t("Expression")).field("computed",Boolean,e.false).field("optional",Boolean,e.false).field("parameters",o),t("TSTypePredicate").bases("TSTypeAnnotation","TSType").build("parameterName","typeAnnotation","asserts").field("parameterName",n(t("Identifier"),t("TSThisType"))).field("typeAnnotation",n(t("TSTypeAnnotation"),null),e.null).field("asserts",Boolean,e.false),["TSCallSignatureDeclaration","TSConstructSignatureDeclaration"].forEach(e=>{t(e).bases("Declaration","TSHasOptionalTypeParameters","TSHasOptionalTypeAnnotation").build("parameters","typeAnnotation").field("parameters",o)}),t("TSEnumMember").bases("Node").build("id","initializer").field("id",n(t("Identifier"),a)).field("initializer",n(t("Expression"),null),e.null),t("TSTypeQuery").bases("TSType").build("exprName").field("exprName",n(l,t("TSImportType"))),n(t("TSCallSignatureDeclaration"),t("TSConstructSignatureDeclaration"),t("TSIndexSignature"),t("TSMethodSignature"),t("TSPropertySignature")));t("TSTypeLiteral").bases("TSType").build("members").field("members",[r]),t("TSTypeParameter").bases("Identifier").build("name","constraint","default").field("name",n(t("Identifier"),String)).field("constraint",n(t("TSType"),void 0),e[void 0]).field("default",n(t("TSType"),void 0),e[void 0]),t("TSTypeAssertion").bases("Expression","Pattern").build("typeAnnotation","expression").field("typeAnnotation",t("TSType")).field("expression",t("Expression")).field("extra",n({parenthesized:Boolean},null),e.null),t("TSTypeParameterDeclaration").bases("Declaration").build("params").field("params",[t("TSTypeParameter")]),t("TSInstantiationExpression").bases("Expression","TSHasOptionalTypeParameterInstantiation").build("expression","typeParameters").field("expression",t("Expression")),t("TSTypeParameterInstantiation").bases("Node").build("params").field("params",[t("TSType")]),t("TSEnumDeclaration").bases("Declaration").build("id","members").field("id",t("Identifier")).field("const",Boolean,e.false).field("declare",Boolean,e.false).field("members",[t("TSEnumMember")]).field("initializer",n(t("Expression"),null),e.null),t("TSTypeAliasDeclaration").bases("Declaration","TSHasOptionalTypeParameters").build("id","typeAnnotation").field("id",t("Identifier")).field("declare",Boolean,e.false).field("typeAnnotation",t("TSType")),t("TSModuleBlock").bases("Node").build("body").field("body",[t("Statement")]),t("TSModuleDeclaration").bases("Declaration").build("id","body").field("id",n(a,l)).field("declare",Boolean,e.false).field("global",Boolean,e.false).field("body",n(t("TSModuleBlock"),t("TSModuleDeclaration"),null),e.null),t("TSImportType").bases("TSType","TSHasOptionalTypeParameterInstantiation").build("argument","qualifier","typeParameters").field("argument",a).field("qualifier",n(l,void 0),e[void 0]),t("TSImportEqualsDeclaration").bases("Declaration").build("id","moduleReference").field("id",t("Identifier")).field("isExport",Boolean,e.false).field("moduleReference",n(l,t("TSExternalModuleReference"))),t("TSExternalModuleReference").bases("Declaration").build("expression").field("expression",a),t("TSExportAssignment").bases("Statement").build("expression").field("expression",t("Expression")),t("TSNamespaceExportDeclaration").bases("Declaration").build("id").field("id",t("Identifier")),t("TSInterfaceBody").bases("Node").build("body").field("body",[r]),t("TSExpressionWithTypeArguments").bases("TSType","TSHasOptionalTypeParameterInstantiation").build("expression","typeParameters").field("expression",l),t("TSInterfaceDeclaration").bases("Declaration","TSHasOptionalTypeParameters").build("id","body").field("id",l).field("declare",Boolean,e.false).field("extends",n([t("TSExpressionWithTypeArguments")],null),e.null).field("body",t("TSInterfaceBody")),t("TSParameterProperty").bases("Pattern").build("parameter").field("accessibility",n("public","private","protected",void 0),e[void 0]).field("readonly",Boolean,e.false).field("parameter",n(t("Identifier"),t("AssignmentPattern"))),t("ClassProperty").field("access",n("public","private","protected",void 0),e[void 0]),t("ClassAccessorProperty").bases("Declaration","TSHasOptionalTypeAnnotation"),t("ClassBody").field("body",[n(t("MethodDefinition"),t("VariableDeclarator"),t("ClassPropertyDefinition"),t("ClassProperty"),t("ClassPrivateProperty"),t("ClassAccessorProperty"),t("ClassMethod"),t("ClassPrivateMethod"),t("StaticBlock"),t("TSDeclareMethod"),r)])}});
//# sourceMappingURL=../sourcemaps/def/typescript.js.map
