/**
 * skylark-asttypes - A version of asttypes that ported to running on skylarkjs.
 * @author Hudaokeji Co.,Ltd
 * @version v0.9.0
 * @link www.skylarkjs.org
 * @license MIT
 */
define(["./babel-core","./type-annotations","../types","../shared"],function(e,a,i,t){"use strict";return function(n){n.use(e),n.use(a);var l=n.use(i),o=l.namedTypes,r=l.Type.def,s=l.Type.or,p=n.use(t).defaults,d=l.Type.from(function(e,a){return!(!o.StringLiteral||!o.StringLiteral.check(e,a))||!(!o.Literal||!o.Literal.check(e,a)||"string"!=typeof e.value)},"StringLiteral");r("TSType").bases("Node");var T=s(r("Identifier"),r("TSQualifiedName"));r("TSTypeReference").bases("TSType","TSHasOptionalTypeParameterInstantiation").build("typeName","typeParameters").field("typeName",T),r("TSHasOptionalTypeParameterInstantiation").field("typeParameters",s(r("TSTypeParameterInstantiation"),null),p.null),r("TSHasOptionalTypeParameters").field("typeParameters",s(r("TSTypeParameterDeclaration"),null,void 0),p.null),r("TSHasOptionalTypeAnnotation").field("typeAnnotation",s(r("TSTypeAnnotation"),null),p.null),r("TSQualifiedName").bases("Node").build("left","right").field("left",T).field("right",T),r("TSAsExpression").bases("Expression","Pattern").build("expression","typeAnnotation").field("expression",r("Expression")).field("typeAnnotation",r("TSType")).field("extra",s({parenthesized:Boolean},null),p.null),r("TSTypeCastExpression").bases("Expression").build("expression","typeAnnotation").field("expression",r("Expression")).field("typeAnnotation",r("TSType")),r("TSSatisfiesExpression").bases("Expression","Pattern").build("expression","typeAnnotation").field("expression",r("Expression")).field("typeAnnotation",r("TSType")),r("TSNonNullExpression").bases("Expression","Pattern").build("expression").field("expression",r("Expression")),["TSAnyKeyword","TSBigIntKeyword","TSBooleanKeyword","TSNeverKeyword","TSNullKeyword","TSNumberKeyword","TSObjectKeyword","TSStringKeyword","TSSymbolKeyword","TSUndefinedKeyword","TSUnknownKeyword","TSVoidKeyword","TSIntrinsicKeyword","TSThisType"].forEach(e=>{r(e).bases("TSType").build()}),r("TSArrayType").bases("TSType").build("elementType").field("elementType",r("TSType")),r("TSLiteralType").bases("TSType").build("literal").field("literal",s(r("NumericLiteral"),r("StringLiteral"),r("BooleanLiteral"),r("TemplateLiteral"),r("UnaryExpression"),r("BigIntLiteral"))),r("TemplateLiteral").field("expressions",s([r("Expression")],[r("TSType")])),["TSUnionType","TSIntersectionType"].forEach(e=>{r(e).bases("TSType").build("types").field("types",[r("TSType")])}),r("TSConditionalType").bases("TSType").build("checkType","extendsType","trueType","falseType").field("checkType",r("TSType")).field("extendsType",r("TSType")).field("trueType",r("TSType")).field("falseType",r("TSType")),r("TSInferType").bases("TSType").build("typeParameter").field("typeParameter",r("TSTypeParameter")),r("TSParenthesizedType").bases("TSType").build("typeAnnotation").field("typeAnnotation",r("TSType"));var y=[s(r("Identifier"),r("RestElement"),r("ArrayPattern"),r("ObjectPattern"))];["TSFunctionType","TSConstructorType"].forEach(e=>{r(e).bases("TSType","TSHasOptionalTypeParameters","TSHasOptionalTypeAnnotation").build("parameters").field("parameters",y)}),r("TSDeclareFunction").bases("Declaration","TSHasOptionalTypeParameters").build("id","params","returnType").field("declare",Boolean,p.false).field("async",Boolean,p.false).field("generator",Boolean,p.false).field("id",s(r("Identifier"),null),p.null).field("params",[r("Pattern")]).field("returnType",s(r("TSTypeAnnotation"),r("Noop"),null),p.null),r("TSDeclareMethod").bases("Declaration","TSHasOptionalTypeParameters").build("key","params","returnType").field("async",Boolean,p.false).field("generator",Boolean,p.false).field("params",[r("Pattern")]).field("abstract",Boolean,p.false).field("accessibility",s("public","private","protected",void 0),p[void 0]).field("static",Boolean,p.false).field("computed",Boolean,p.false).field("optional",Boolean,p.false).field("key",s(r("Identifier"),r("StringLiteral"),r("NumericLiteral"),r("Expression"))).field("kind",s("get","set","method","constructor"),function(){return"method"}).field("access",s("public","private","protected",void 0),p[void 0]).field("decorators",s([r("Decorator")],null),p.null).field("returnType",s(r("TSTypeAnnotation"),r("Noop"),null),p.null),r("TSMappedType").bases("TSType").build("typeParameter","typeAnnotation").field("readonly",s(Boolean,"+","-"),p.false).field("typeParameter",r("TSTypeParameter")).field("optional",s(Boolean,"+","-"),p.false).field("typeAnnotation",s(r("TSType"),null),p.null),r("TSTupleType").bases("TSType").build("elementTypes").field("elementTypes",[s(r("TSType"),r("TSNamedTupleMember"))]),r("TSNamedTupleMember").bases("TSType").build("label","elementType","optional").field("label",r("Identifier")).field("optional",Boolean,p.false).field("elementType",r("TSType")),r("TSRestType").bases("TSType").build("typeAnnotation").field("typeAnnotation",r("TSType")),r("TSOptionalType").bases("TSType").build("typeAnnotation").field("typeAnnotation",r("TSType")),r("TSIndexedAccessType").bases("TSType").build("objectType","indexType").field("objectType",r("TSType")).field("indexType",r("TSType")),r("TSTypeOperator").bases("TSType").build("operator").field("operator",String).field("typeAnnotation",r("TSType")),r("TSTypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation",s(r("TSType"),r("TSTypeAnnotation"))),r("TSIndexSignature").bases("Declaration","TSHasOptionalTypeAnnotation").build("parameters","typeAnnotation").field("parameters",[r("Identifier")]).field("readonly",Boolean,p.false),r("TSPropertySignature").bases("Declaration","TSHasOptionalTypeAnnotation").build("key","typeAnnotation","optional").field("key",r("Expression")).field("computed",Boolean,p.false).field("readonly",Boolean,p.false).field("optional",Boolean,p.false).field("initializer",s(r("Expression"),null),p.null),r("TSMethodSignature").bases("Declaration","TSHasOptionalTypeParameters","TSHasOptionalTypeAnnotation").build("key","parameters","typeAnnotation").field("key",r("Expression")).field("computed",Boolean,p.false).field("optional",Boolean,p.false).field("parameters",y),r("TSTypePredicate").bases("TSTypeAnnotation","TSType").build("parameterName","typeAnnotation","asserts").field("parameterName",s(r("Identifier"),r("TSThisType"))).field("typeAnnotation",s(r("TSTypeAnnotation"),null),p.null).field("asserts",Boolean,p.false),["TSCallSignatureDeclaration","TSConstructSignatureDeclaration"].forEach(e=>{r(e).bases("Declaration","TSHasOptionalTypeParameters","TSHasOptionalTypeAnnotation").build("parameters","typeAnnotation").field("parameters",y)}),r("TSEnumMember").bases("Node").build("id","initializer").field("id",s(r("Identifier"),d)).field("initializer",s(r("Expression"),null),p.null),r("TSTypeQuery").bases("TSType").build("exprName").field("exprName",s(T,r("TSImportType")));var f=s(r("TSCallSignatureDeclaration"),r("TSConstructSignatureDeclaration"),r("TSIndexSignature"),r("TSMethodSignature"),r("TSPropertySignature"));r("TSTypeLiteral").bases("TSType").build("members").field("members",[f]),r("TSTypeParameter").bases("Identifier").build("name","constraint","default").field("name",s(r("Identifier"),String)).field("constraint",s(r("TSType"),void 0),p[void 0]).field("default",s(r("TSType"),void 0),p[void 0]),r("TSTypeAssertion").bases("Expression","Pattern").build("typeAnnotation","expression").field("typeAnnotation",r("TSType")).field("expression",r("Expression")).field("extra",s({parenthesized:Boolean},null),p.null),r("TSTypeParameterDeclaration").bases("Declaration").build("params").field("params",[r("TSTypeParameter")]),r("TSInstantiationExpression").bases("Expression","TSHasOptionalTypeParameterInstantiation").build("expression","typeParameters").field("expression",r("Expression")),r("TSTypeParameterInstantiation").bases("Node").build("params").field("params",[r("TSType")]),r("TSEnumDeclaration").bases("Declaration").build("id","members").field("id",r("Identifier")).field("const",Boolean,p.false).field("declare",Boolean,p.false).field("members",[r("TSEnumMember")]).field("initializer",s(r("Expression"),null),p.null),r("TSTypeAliasDeclaration").bases("Declaration","TSHasOptionalTypeParameters").build("id","typeAnnotation").field("id",r("Identifier")).field("declare",Boolean,p.false).field("typeAnnotation",r("TSType")),r("TSModuleBlock").bases("Node").build("body").field("body",[r("Statement")]),r("TSModuleDeclaration").bases("Declaration").build("id","body").field("id",s(d,T)).field("declare",Boolean,p.false).field("global",Boolean,p.false).field("body",s(r("TSModuleBlock"),r("TSModuleDeclaration"),null),p.null),r("TSImportType").bases("TSType","TSHasOptionalTypeParameterInstantiation").build("argument","qualifier","typeParameters").field("argument",d).field("qualifier",s(T,void 0),p[void 0]),r("TSImportEqualsDeclaration").bases("Declaration").build("id","moduleReference").field("id",r("Identifier")).field("isExport",Boolean,p.false).field("moduleReference",s(T,r("TSExternalModuleReference"))),r("TSExternalModuleReference").bases("Declaration").build("expression").field("expression",d),r("TSExportAssignment").bases("Statement").build("expression").field("expression",r("Expression")),r("TSNamespaceExportDeclaration").bases("Declaration").build("id").field("id",r("Identifier")),r("TSInterfaceBody").bases("Node").build("body").field("body",[f]),r("TSExpressionWithTypeArguments").bases("TSType","TSHasOptionalTypeParameterInstantiation").build("expression","typeParameters").field("expression",T),r("TSInterfaceDeclaration").bases("Declaration","TSHasOptionalTypeParameters").build("id","body").field("id",T).field("declare",Boolean,p.false).field("extends",s([r("TSExpressionWithTypeArguments")],null),p.null).field("body",r("TSInterfaceBody")),r("TSParameterProperty").bases("Pattern").build("parameter").field("accessibility",s("public","private","protected",void 0),p[void 0]).field("readonly",Boolean,p.false).field("parameter",s(r("Identifier"),r("AssignmentPattern"))),r("ClassProperty").field("access",s("public","private","protected",void 0),p[void 0]),r("ClassAccessorProperty").bases("Declaration","TSHasOptionalTypeAnnotation"),r("ClassBody").field("body",[s(r("MethodDefinition"),r("VariableDeclarator"),r("ClassPropertyDefinition"),r("ClassProperty"),r("ClassPrivateProperty"),r("ClassAccessorProperty"),r("ClassMethod"),r("ClassPrivateMethod"),r("StaticBlock"),r("TSDeclareMethod"),f)])}});
//# sourceMappingURL=../sourcemaps/def/typescript.js.map
